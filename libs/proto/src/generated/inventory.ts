// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: inventory.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "inventory";

export interface CheckStockRequest {
  skuCodes: string[];
}

export interface StockItem {
  skuCode: string;
  stock: number;
}

export interface CheckStockResponse {
  items: StockItem[];
}

export interface ReserveStockRequest {
  items: ReserveStockItem[];
}

export interface ReserveStockItem {
  skuCode: string;
  quantity: number;
}

export interface ReserveStockResponse {
  success: boolean;
  reservedSkuCodes: string[];
}

export interface SyncStockFromRedisRequest {
  skuCodes: string[];
}

export interface SyncStockFromRedisResponse {
  success: boolean;
  syncedSkuCodes: string[];
}

function createBaseCheckStockRequest(): CheckStockRequest {
  return { skuCodes: [] };
}

export const CheckStockRequest: MessageFns<CheckStockRequest> = {
  encode(message: CheckStockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.skuCodes) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckStockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckStockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.skuCodes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckStockRequest {
    return {
      skuCodes: globalThis.Array.isArray(object?.skuCodes) ? object.skuCodes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: CheckStockRequest): unknown {
    const obj: any = {};
    if (message.skuCodes?.length) {
      obj.skuCodes = message.skuCodes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckStockRequest>, I>>(base?: I): CheckStockRequest {
    return CheckStockRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckStockRequest>, I>>(object: I): CheckStockRequest {
    const message = createBaseCheckStockRequest();
    message.skuCodes = object.skuCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseStockItem(): StockItem {
  return { skuCode: "", stock: 0 };
}

export const StockItem: MessageFns<StockItem> = {
  encode(message: StockItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.skuCode !== "") {
      writer.uint32(10).string(message.skuCode);
    }
    if (message.stock !== 0) {
      writer.uint32(16).int32(message.stock);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StockItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStockItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.stock = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StockItem {
    return {
      skuCode: isSet(object.skuCode) ? globalThis.String(object.skuCode) : "",
      stock: isSet(object.stock) ? globalThis.Number(object.stock) : 0,
    };
  },

  toJSON(message: StockItem): unknown {
    const obj: any = {};
    if (message.skuCode !== "") {
      obj.skuCode = message.skuCode;
    }
    if (message.stock !== 0) {
      obj.stock = Math.round(message.stock);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StockItem>, I>>(base?: I): StockItem {
    return StockItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StockItem>, I>>(object: I): StockItem {
    const message = createBaseStockItem();
    message.skuCode = object.skuCode ?? "";
    message.stock = object.stock ?? 0;
    return message;
  },
};

function createBaseCheckStockResponse(): CheckStockResponse {
  return { items: [] };
}

export const CheckStockResponse: MessageFns<CheckStockResponse> = {
  encode(message: CheckStockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      StockItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CheckStockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckStockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(StockItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CheckStockResponse {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => StockItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: CheckStockResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => StockItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CheckStockResponse>, I>>(base?: I): CheckStockResponse {
    return CheckStockResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CheckStockResponse>, I>>(object: I): CheckStockResponse {
    const message = createBaseCheckStockResponse();
    message.items = object.items?.map((e) => StockItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReserveStockRequest(): ReserveStockRequest {
  return { items: [] };
}

export const ReserveStockRequest: MessageFns<ReserveStockRequest> = {
  encode(message: ReserveStockRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      ReserveStockItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReserveStockRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveStockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(ReserveStockItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReserveStockRequest {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => ReserveStockItem.fromJSON(e)) : [],
    };
  },

  toJSON(message: ReserveStockRequest): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => ReserveStockItem.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReserveStockRequest>, I>>(base?: I): ReserveStockRequest {
    return ReserveStockRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReserveStockRequest>, I>>(object: I): ReserveStockRequest {
    const message = createBaseReserveStockRequest();
    message.items = object.items?.map((e) => ReserveStockItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseReserveStockItem(): ReserveStockItem {
  return { skuCode: "", quantity: 0 };
}

export const ReserveStockItem: MessageFns<ReserveStockItem> = {
  encode(message: ReserveStockItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.skuCode !== "") {
      writer.uint32(10).string(message.skuCode);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReserveStockItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveStockItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReserveStockItem {
    return {
      skuCode: isSet(object.skuCode) ? globalThis.String(object.skuCode) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: ReserveStockItem): unknown {
    const obj: any = {};
    if (message.skuCode !== "") {
      obj.skuCode = message.skuCode;
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReserveStockItem>, I>>(base?: I): ReserveStockItem {
    return ReserveStockItem.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReserveStockItem>, I>>(object: I): ReserveStockItem {
    const message = createBaseReserveStockItem();
    message.skuCode = object.skuCode ?? "";
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseReserveStockResponse(): ReserveStockResponse {
  return { success: false, reservedSkuCodes: [] };
}

export const ReserveStockResponse: MessageFns<ReserveStockResponse> = {
  encode(message: ReserveStockResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.reservedSkuCodes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReserveStockResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveStockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reservedSkuCodes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReserveStockResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      reservedSkuCodes: globalThis.Array.isArray(object?.reservedSkuCodes)
        ? object.reservedSkuCodes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ReserveStockResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.reservedSkuCodes?.length) {
      obj.reservedSkuCodes = message.reservedSkuCodes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReserveStockResponse>, I>>(base?: I): ReserveStockResponse {
    return ReserveStockResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReserveStockResponse>, I>>(object: I): ReserveStockResponse {
    const message = createBaseReserveStockResponse();
    message.success = object.success ?? false;
    message.reservedSkuCodes = object.reservedSkuCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseSyncStockFromRedisRequest(): SyncStockFromRedisRequest {
  return { skuCodes: [] };
}

export const SyncStockFromRedisRequest: MessageFns<SyncStockFromRedisRequest> = {
  encode(message: SyncStockFromRedisRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.skuCodes) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncStockFromRedisRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncStockFromRedisRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.skuCodes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncStockFromRedisRequest {
    return {
      skuCodes: globalThis.Array.isArray(object?.skuCodes) ? object.skuCodes.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: SyncStockFromRedisRequest): unknown {
    const obj: any = {};
    if (message.skuCodes?.length) {
      obj.skuCodes = message.skuCodes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncStockFromRedisRequest>, I>>(base?: I): SyncStockFromRedisRequest {
    return SyncStockFromRedisRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncStockFromRedisRequest>, I>>(object: I): SyncStockFromRedisRequest {
    const message = createBaseSyncStockFromRedisRequest();
    message.skuCodes = object.skuCodes?.map((e) => e) || [];
    return message;
  },
};

function createBaseSyncStockFromRedisResponse(): SyncStockFromRedisResponse {
  return { success: false, syncedSkuCodes: [] };
}

export const SyncStockFromRedisResponse: MessageFns<SyncStockFromRedisResponse> = {
  encode(message: SyncStockFromRedisResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.syncedSkuCodes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncStockFromRedisResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncStockFromRedisResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.syncedSkuCodes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncStockFromRedisResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      syncedSkuCodes: globalThis.Array.isArray(object?.syncedSkuCodes)
        ? object.syncedSkuCodes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SyncStockFromRedisResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.syncedSkuCodes?.length) {
      obj.syncedSkuCodes = message.syncedSkuCodes;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SyncStockFromRedisResponse>, I>>(base?: I): SyncStockFromRedisResponse {
    return SyncStockFromRedisResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SyncStockFromRedisResponse>, I>>(object: I): SyncStockFromRedisResponse {
    const message = createBaseSyncStockFromRedisResponse();
    message.success = object.success ?? false;
    message.syncedSkuCodes = object.syncedSkuCodes?.map((e) => e) || [];
    return message;
  },
};

export interface InventoryService {
  CheckStock(request: CheckStockRequest): Promise<CheckStockResponse>;
  ReserveStock(request: ReserveStockRequest): Promise<ReserveStockResponse>;
  SyncStockFromRedis(request: SyncStockFromRedisRequest): Promise<SyncStockFromRedisResponse>;
}

export const InventoryServiceServiceName = "inventory.InventoryService";
export class InventoryServiceClientImpl implements InventoryService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || InventoryServiceServiceName;
    this.rpc = rpc;
    this.CheckStock = this.CheckStock.bind(this);
    this.ReserveStock = this.ReserveStock.bind(this);
    this.SyncStockFromRedis = this.SyncStockFromRedis.bind(this);
  }
  CheckStock(request: CheckStockRequest): Promise<CheckStockResponse> {
    const data = CheckStockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "CheckStock", data);
    return promise.then((data) => CheckStockResponse.decode(new BinaryReader(data)));
  }

  ReserveStock(request: ReserveStockRequest): Promise<ReserveStockResponse> {
    const data = ReserveStockRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ReserveStock", data);
    return promise.then((data) => ReserveStockResponse.decode(new BinaryReader(data)));
  }

  SyncStockFromRedis(request: SyncStockFromRedisRequest): Promise<SyncStockFromRedisResponse> {
    const data = SyncStockFromRedisRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "SyncStockFromRedis", data);
    return promise.then((data) => SyncStockFromRedisResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
