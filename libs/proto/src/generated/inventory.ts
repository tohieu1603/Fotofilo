// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: inventory.proto

/* eslint-disable */
import { type handleUnaryCall, Metadata, type UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import * as _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";

export const protobufPackage = "inventory";

export enum StockLogType {
  IMPORT = 0,
  EXPORT = 1,
  ADJUSTMENT = 2,
  ROLLBACK = 3,
  ORDER = 4,
  FLASH_SALE = 5,
  UNRECOGNIZED = -1,
}

export interface CheckStockRequest {
  skuCodes: string[];
}

export interface StockItem {
  skuCode: string;
  stock: number;
}

export interface CheckStockResponse {
  items: StockItem[];
}

export interface ReserveStockRequest {
  items: ReserveStockItem[];
}

export interface ReserveStockItem {
  skuCode: string;
  quantity: number;
}

export interface ReserveStockResponse {
  success: boolean;
  reservedSkuCodes: string[];
}

export interface SyncStockFromRedisRequest {
  skuCodes: string[];
}

export interface SyncStockFromRedisResponse {
  success: boolean;
  syncedSkuCodes: string[];
}

/** New messages for detailed inventory management */
export interface GetStockRequest {
  skuCode: string;
}

export interface InventoryStock {
  id: string;
  skuId: string;
  skuCode: string;
  stock: number;
  createdAt: string;
  updatedAt: string;
}

export interface GetStockResponse {
  stock?: InventoryStock | undefined;
}

export interface GetStockLogsRequest {
  skuCode: string;
}

export interface StockLog {
  id: string;
  skuId: string;
  skuCode: string;
  type: StockLogType;
  stock: number;
  beforeQuantity: number;
  afterQuantity: number;
  referenceId: string;
  note: string;
  importSource: string;
  importBatch: string;
  supplierName: string;
  importPrice: number;
  createdAt: string;
}

export interface GetStockLogsResponse {
  logs: StockLog[];
}

export interface ImportDetails {
  importSource: string;
  importBatch: string;
  supplierName: string;
  importPrice: number;
  note: string;
}

export interface ImportStockRequest {
  skuCode: string;
  quantity: number;
  importDetails?: ImportDetails | undefined;
}

export interface ImportStockResponse {
  success: boolean;
  message: string;
}

export interface AdjustStockRequest {
  skuCode: string;
  newQuantity: number;
  reason: string;
}

export interface AdjustStockResponse {
  success: boolean;
  message: string;
}

export const INVENTORY_PACKAGE_NAME = "inventory";

function createBaseCheckStockRequest(): CheckStockRequest {
  return { skuCodes: [] };
}

export const CheckStockRequest = {
  encode(message: CheckStockRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.skuCodes) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckStockRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckStockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuCodes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseStockItem(): StockItem {
  return { skuCode: "", stock: 0 };
}

export const StockItem = {
  encode(message: StockItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skuCode !== "") {
      writer.uint32(10).string(message.skuCode);
    }
    if (message.stock !== 0) {
      writer.uint32(16).int32(message.stock);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StockItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStockItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.stock = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCheckStockResponse(): CheckStockResponse {
  return { items: [] };
}

export const CheckStockResponse = {
  encode(message: CheckStockResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      StockItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckStockResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckStockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(StockItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseReserveStockRequest(): ReserveStockRequest {
  return { items: [] };
}

export const ReserveStockRequest = {
  encode(message: ReserveStockRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      ReserveStockItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReserveStockRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveStockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(ReserveStockItem.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseReserveStockItem(): ReserveStockItem {
  return { skuCode: "", quantity: 0 };
}

export const ReserveStockItem = {
  encode(message: ReserveStockItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skuCode !== "") {
      writer.uint32(10).string(message.skuCode);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReserveStockItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveStockItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseReserveStockResponse(): ReserveStockResponse {
  return { success: false, reservedSkuCodes: [] };
}

export const ReserveStockResponse = {
  encode(message: ReserveStockResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.reservedSkuCodes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ReserveStockResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReserveStockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reservedSkuCodes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseSyncStockFromRedisRequest(): SyncStockFromRedisRequest {
  return { skuCodes: [] };
}

export const SyncStockFromRedisRequest = {
  encode(message: SyncStockFromRedisRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.skuCodes) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SyncStockFromRedisRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncStockFromRedisRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuCodes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseSyncStockFromRedisResponse(): SyncStockFromRedisResponse {
  return { success: false, syncedSkuCodes: [] };
}

export const SyncStockFromRedisResponse = {
  encode(message: SyncStockFromRedisResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.syncedSkuCodes) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SyncStockFromRedisResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncStockFromRedisResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.syncedSkuCodes.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetStockRequest(): GetStockRequest {
  return { skuCode: "" };
}

export const GetStockRequest = {
  encode(message: GetStockRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skuCode !== "") {
      writer.uint32(10).string(message.skuCode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStockRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseInventoryStock(): InventoryStock {
  return { id: "", skuId: "", skuCode: "", stock: 0, createdAt: "", updatedAt: "" };
}

export const InventoryStock = {
  encode(message: InventoryStock, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.skuId !== "") {
      writer.uint32(18).string(message.skuId);
    }
    if (message.skuCode !== "") {
      writer.uint32(26).string(message.skuCode);
    }
    if (message.stock !== 0) {
      writer.uint32(32).int32(message.stock);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(50).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): InventoryStock {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInventoryStock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skuId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.stock = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetStockResponse(): GetStockResponse {
  return {};
}

export const GetStockResponse = {
  encode(message: GetStockResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.stock !== undefined) {
      InventoryStock.encode(message.stock, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStockResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.stock = InventoryStock.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetStockLogsRequest(): GetStockLogsRequest {
  return { skuCode: "" };
}

export const GetStockLogsRequest = {
  encode(message: GetStockLogsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skuCode !== "") {
      writer.uint32(10).string(message.skuCode);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStockLogsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStockLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuCode = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseStockLog(): StockLog {
  return {
    id: "",
    skuId: "",
    skuCode: "",
    type: 0,
    stock: 0,
    beforeQuantity: 0,
    afterQuantity: 0,
    referenceId: "",
    note: "",
    importSource: "",
    importBatch: "",
    supplierName: "",
    importPrice: 0,
    createdAt: "",
  };
}

export const StockLog = {
  encode(message: StockLog, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.skuId !== "") {
      writer.uint32(18).string(message.skuId);
    }
    if (message.skuCode !== "") {
      writer.uint32(26).string(message.skuCode);
    }
    if (message.type !== 0) {
      writer.uint32(32).int32(message.type);
    }
    if (message.stock !== 0) {
      writer.uint32(40).int32(message.stock);
    }
    if (message.beforeQuantity !== 0) {
      writer.uint32(48).int32(message.beforeQuantity);
    }
    if (message.afterQuantity !== 0) {
      writer.uint32(56).int32(message.afterQuantity);
    }
    if (message.referenceId !== "") {
      writer.uint32(66).string(message.referenceId);
    }
    if (message.note !== "") {
      writer.uint32(74).string(message.note);
    }
    if (message.importSource !== "") {
      writer.uint32(82).string(message.importSource);
    }
    if (message.importBatch !== "") {
      writer.uint32(90).string(message.importBatch);
    }
    if (message.supplierName !== "") {
      writer.uint32(98).string(message.supplierName);
    }
    if (message.importPrice !== 0) {
      writer.uint32(105).double(message.importPrice);
    }
    if (message.createdAt !== "") {
      writer.uint32(114).string(message.createdAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): StockLog {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStockLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skuId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.stock = reader.int32();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.beforeQuantity = reader.int32();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.afterQuantity = reader.int32();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.note = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.importSource = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.importBatch = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.supplierName = reader.string();
          continue;
        case 13:
          if (tag !== 105) {
            break;
          }

          message.importPrice = reader.double();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.createdAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetStockLogsResponse(): GetStockLogsResponse {
  return { logs: [] };
}

export const GetStockLogsResponse = {
  encode(message: GetStockLogsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.logs) {
      StockLog.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetStockLogsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStockLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.logs.push(StockLog.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseImportDetails(): ImportDetails {
  return { importSource: "", importBatch: "", supplierName: "", importPrice: 0, note: "" };
}

export const ImportDetails = {
  encode(message: ImportDetails, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.importSource !== "") {
      writer.uint32(10).string(message.importSource);
    }
    if (message.importBatch !== "") {
      writer.uint32(18).string(message.importBatch);
    }
    if (message.supplierName !== "") {
      writer.uint32(26).string(message.supplierName);
    }
    if (message.importPrice !== 0) {
      writer.uint32(33).double(message.importPrice);
    }
    if (message.note !== "") {
      writer.uint32(42).string(message.note);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ImportDetails {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.importSource = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.importBatch = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.supplierName = reader.string();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.importPrice = reader.double();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.note = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseImportStockRequest(): ImportStockRequest {
  return { skuCode: "", quantity: 0 };
}

export const ImportStockRequest = {
  encode(message: ImportStockRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skuCode !== "") {
      writer.uint32(10).string(message.skuCode);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    if (message.importDetails !== undefined) {
      ImportDetails.encode(message.importDetails, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ImportStockRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportStockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.importDetails = ImportDetails.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseImportStockResponse(): ImportStockResponse {
  return { success: false, message: "" };
}

export const ImportStockResponse = {
  encode(message: ImportStockResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ImportStockResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseImportStockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAdjustStockRequest(): AdjustStockRequest {
  return { skuCode: "", newQuantity: 0, reason: "" };
}

export const AdjustStockRequest = {
  encode(message: AdjustStockRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skuCode !== "") {
      writer.uint32(10).string(message.skuCode);
    }
    if (message.newQuantity !== 0) {
      writer.uint32(16).int32(message.newQuantity);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AdjustStockRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdjustStockRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.newQuantity = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAdjustStockResponse(): AdjustStockResponse {
  return { success: false, message: "" };
}

export const AdjustStockResponse = {
  encode(message: AdjustStockResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AdjustStockResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAdjustStockResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

export interface InventoryServiceClient {
  checkStock(request: CheckStockRequest, metadata: Metadata, ...rest: any): Observable<CheckStockResponse>;

  reserveStock(request: ReserveStockRequest, metadata: Metadata, ...rest: any): Observable<ReserveStockResponse>;

  syncStockFromRedis(
    request: SyncStockFromRedisRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<SyncStockFromRedisResponse>;

  getStock(request: GetStockRequest, metadata: Metadata, ...rest: any): Observable<GetStockResponse>;

  getStockLogs(request: GetStockLogsRequest, metadata: Metadata, ...rest: any): Observable<GetStockLogsResponse>;

  importStock(request: ImportStockRequest, metadata: Metadata, ...rest: any): Observable<ImportStockResponse>;

  adjustStock(request: AdjustStockRequest, metadata: Metadata, ...rest: any): Observable<AdjustStockResponse>;
}

export interface InventoryServiceController {
  checkStock(
    request: CheckStockRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CheckStockResponse> | Observable<CheckStockResponse> | CheckStockResponse;

  reserveStock(
    request: ReserveStockRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<ReserveStockResponse> | Observable<ReserveStockResponse> | ReserveStockResponse;

  syncStockFromRedis(
    request: SyncStockFromRedisRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<SyncStockFromRedisResponse> | Observable<SyncStockFromRedisResponse> | SyncStockFromRedisResponse;

  getStock(
    request: GetStockRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetStockResponse> | Observable<GetStockResponse> | GetStockResponse;

  getStockLogs(
    request: GetStockLogsRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetStockLogsResponse> | Observable<GetStockLogsResponse> | GetStockLogsResponse;

  importStock(
    request: ImportStockRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<ImportStockResponse> | Observable<ImportStockResponse> | ImportStockResponse;

  adjustStock(
    request: AdjustStockRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<AdjustStockResponse> | Observable<AdjustStockResponse> | AdjustStockResponse;
}

export function InventoryServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "checkStock",
      "reserveStock",
      "syncStockFromRedis",
      "getStock",
      "getStockLogs",
      "importStock",
      "adjustStock",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("InventoryService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("InventoryService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const INVENTORY_SERVICE_NAME = "InventoryService";

export type InventoryServiceService = typeof InventoryServiceService;
export const InventoryServiceService = {
  checkStock: {
    path: "/inventory.InventoryService/CheckStock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckStockRequest) => Buffer.from(CheckStockRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CheckStockRequest.decode(value),
    responseSerialize: (value: CheckStockResponse) => Buffer.from(CheckStockResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckStockResponse.decode(value),
  },
  reserveStock: {
    path: "/inventory.InventoryService/ReserveStock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReserveStockRequest) => Buffer.from(ReserveStockRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ReserveStockRequest.decode(value),
    responseSerialize: (value: ReserveStockResponse) => Buffer.from(ReserveStockResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ReserveStockResponse.decode(value),
  },
  syncStockFromRedis: {
    path: "/inventory.InventoryService/SyncStockFromRedis",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: SyncStockFromRedisRequest) =>
      Buffer.from(SyncStockFromRedisRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => SyncStockFromRedisRequest.decode(value),
    responseSerialize: (value: SyncStockFromRedisResponse) =>
      Buffer.from(SyncStockFromRedisResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => SyncStockFromRedisResponse.decode(value),
  },
  getStock: {
    path: "/inventory.InventoryService/GetStock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStockRequest) => Buffer.from(GetStockRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetStockRequest.decode(value),
    responseSerialize: (value: GetStockResponse) => Buffer.from(GetStockResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetStockResponse.decode(value),
  },
  getStockLogs: {
    path: "/inventory.InventoryService/GetStockLogs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStockLogsRequest) => Buffer.from(GetStockLogsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetStockLogsRequest.decode(value),
    responseSerialize: (value: GetStockLogsResponse) => Buffer.from(GetStockLogsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetStockLogsResponse.decode(value),
  },
  importStock: {
    path: "/inventory.InventoryService/ImportStock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ImportStockRequest) => Buffer.from(ImportStockRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ImportStockRequest.decode(value),
    responseSerialize: (value: ImportStockResponse) => Buffer.from(ImportStockResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ImportStockResponse.decode(value),
  },
  adjustStock: {
    path: "/inventory.InventoryService/AdjustStock",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AdjustStockRequest) => Buffer.from(AdjustStockRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AdjustStockRequest.decode(value),
    responseSerialize: (value: AdjustStockResponse) => Buffer.from(AdjustStockResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AdjustStockResponse.decode(value),
  },
} as const;

export interface InventoryServiceServer extends UntypedServiceImplementation {
  checkStock: handleUnaryCall<CheckStockRequest, CheckStockResponse>;
  reserveStock: handleUnaryCall<ReserveStockRequest, ReserveStockResponse>;
  syncStockFromRedis: handleUnaryCall<SyncStockFromRedisRequest, SyncStockFromRedisResponse>;
  getStock: handleUnaryCall<GetStockRequest, GetStockResponse>;
  getStockLogs: handleUnaryCall<GetStockLogsRequest, GetStockLogsResponse>;
  importStock: handleUnaryCall<ImportStockRequest, ImportStockResponse>;
  adjustStock: handleUnaryCall<AdjustStockRequest, AdjustStockResponse>;
}
