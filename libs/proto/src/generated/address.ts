// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: address.proto

/* eslint-disable */
import { type handleUnaryCall, Metadata, type UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import * as _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import { Empty } from "./google/protobuf/empty";

export const protobufPackage = "address";

export interface Address {
  id: string;
  userId: string;
  fullName: string;
  phoneNumber: string;
  email: string;
  city: string;
  district: string;
  ward: string;
  streetAddress: string;
}

export interface CreateAddressRequest {
  userId: string;
  fullName: string;
  phoneNumber: string;
  email: string;
  city: string;
  district: string;
  ward: string;
  streetAddress: string;
}

export interface UpdateAddressRequest {
  id: string;
  fullName: string;
  phoneNumber: string;
  email: string;
  city: string;
  district: string;
  ward: string;
  streetAddress: string;
}

export interface GetAddressRequest {
  id: string;
}

export interface DeleteAddressRequest {
  id: string;
}

export interface ListAddressesByUserRequest {
  userId: string;
}

export interface AddressResponse {
  address?: Address | undefined;
}

export interface ListAddressesResponse {
  addresses: Address[];
}

export const ADDRESS_PACKAGE_NAME = "address";

function createBaseAddress(): Address {
  return {
    id: "",
    userId: "",
    fullName: "",
    phoneNumber: "",
    email: "",
    city: "",
    district: "",
    ward: "",
    streetAddress: "",
  };
}

export const Address = {
  encode(message: Address, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== "") {
      writer.uint32(18).string(message.userId);
    }
    if (message.fullName !== "") {
      writer.uint32(26).string(message.fullName);
    }
    if (message.phoneNumber !== "") {
      writer.uint32(34).string(message.phoneNumber);
    }
    if (message.email !== "") {
      writer.uint32(42).string(message.email);
    }
    if (message.city !== "") {
      writer.uint32(50).string(message.city);
    }
    if (message.district !== "") {
      writer.uint32(58).string(message.district);
    }
    if (message.ward !== "") {
      writer.uint32(66).string(message.ward);
    }
    if (message.streetAddress !== "") {
      writer.uint32(74).string(message.streetAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Address {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.fullName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.email = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.city = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.district = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.ward = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.streetAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreateAddressRequest(): CreateAddressRequest {
  return { userId: "", fullName: "", phoneNumber: "", email: "", city: "", district: "", ward: "", streetAddress: "" };
}

export const CreateAddressRequest = {
  encode(message: CreateAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.fullName !== "") {
      writer.uint32(18).string(message.fullName);
    }
    if (message.phoneNumber !== "") {
      writer.uint32(26).string(message.phoneNumber);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.city !== "") {
      writer.uint32(42).string(message.city);
    }
    if (message.district !== "") {
      writer.uint32(50).string(message.district);
    }
    if (message.ward !== "") {
      writer.uint32(58).string(message.ward);
    }
    if (message.streetAddress !== "") {
      writer.uint32(66).string(message.streetAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fullName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.city = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.district = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ward = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.streetAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateAddressRequest(): UpdateAddressRequest {
  return { id: "", fullName: "", phoneNumber: "", email: "", city: "", district: "", ward: "", streetAddress: "" };
}

export const UpdateAddressRequest = {
  encode(message: UpdateAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.fullName !== "") {
      writer.uint32(18).string(message.fullName);
    }
    if (message.phoneNumber !== "") {
      writer.uint32(26).string(message.phoneNumber);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.city !== "") {
      writer.uint32(42).string(message.city);
    }
    if (message.district !== "") {
      writer.uint32(50).string(message.district);
    }
    if (message.ward !== "") {
      writer.uint32(58).string(message.ward);
    }
    if (message.streetAddress !== "") {
      writer.uint32(66).string(message.streetAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fullName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.phoneNumber = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.city = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.district = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ward = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.streetAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAddressRequest(): GetAddressRequest {
  return { id: "" };
}

export const GetAddressRequest = {
  encode(message: GetAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteAddressRequest(): DeleteAddressRequest {
  return { id: "" };
}

export const DeleteAddressRequest = {
  encode(message: DeleteAddressRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteAddressRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteAddressRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseListAddressesByUserRequest(): ListAddressesByUserRequest {
  return { userId: "" };
}

export const ListAddressesByUserRequest = {
  encode(message: ListAddressesByUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListAddressesByUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAddressesByUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAddressResponse(): AddressResponse {
  return {};
}

export const AddressResponse = {
  encode(message: AddressResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.address !== undefined) {
      Address.encode(message.address, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddressResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddressResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.address = Address.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseListAddressesResponse(): ListAddressesResponse {
  return { addresses: [] };
}

export const ListAddressesResponse = {
  encode(message: ListAddressesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.addresses) {
      Address.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListAddressesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListAddressesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.addresses.push(Address.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

export interface AddressServiceClient {
  createAddress(request: CreateAddressRequest, metadata: Metadata, ...rest: any): Observable<AddressResponse>;

  getAddress(request: GetAddressRequest, metadata: Metadata, ...rest: any): Observable<AddressResponse>;

  updateAddress(request: UpdateAddressRequest, metadata: Metadata, ...rest: any): Observable<AddressResponse>;

  deleteAddress(request: DeleteAddressRequest, metadata: Metadata, ...rest: any): Observable<Empty>;

  listAddressesByUser(
    request: ListAddressesByUserRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<ListAddressesResponse>;
}

export interface AddressServiceController {
  createAddress(
    request: CreateAddressRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<AddressResponse> | Observable<AddressResponse> | AddressResponse;

  getAddress(
    request: GetAddressRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<AddressResponse> | Observable<AddressResponse> | AddressResponse;

  updateAddress(
    request: UpdateAddressRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<AddressResponse> | Observable<AddressResponse> | AddressResponse;

  deleteAddress(request: DeleteAddressRequest, metadata: Metadata, ...rest: any): void;

  listAddressesByUser(
    request: ListAddressesByUserRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<ListAddressesResponse> | Observable<ListAddressesResponse> | ListAddressesResponse;
}

export function AddressServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createAddress",
      "getAddress",
      "updateAddress",
      "deleteAddress",
      "listAddressesByUser",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AddressService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AddressService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const ADDRESS_SERVICE_NAME = "AddressService";

export type AddressServiceService = typeof AddressServiceService;
export const AddressServiceService = {
  createAddress: {
    path: "/address.AddressService/CreateAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateAddressRequest) => Buffer.from(CreateAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateAddressRequest.decode(value),
    responseSerialize: (value: AddressResponse) => Buffer.from(AddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AddressResponse.decode(value),
  },
  getAddress: {
    path: "/address.AddressService/GetAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAddressRequest) => Buffer.from(GetAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAddressRequest.decode(value),
    responseSerialize: (value: AddressResponse) => Buffer.from(AddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AddressResponse.decode(value),
  },
  updateAddress: {
    path: "/address.AddressService/UpdateAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateAddressRequest) => Buffer.from(UpdateAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateAddressRequest.decode(value),
    responseSerialize: (value: AddressResponse) => Buffer.from(AddressResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AddressResponse.decode(value),
  },
  deleteAddress: {
    path: "/address.AddressService/DeleteAddress",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteAddressRequest) => Buffer.from(DeleteAddressRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteAddressRequest.decode(value),
    responseSerialize: (value: Empty) => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
  listAddressesByUser: {
    path: "/address.AddressService/ListAddressesByUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListAddressesByUserRequest) =>
      Buffer.from(ListAddressesByUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListAddressesByUserRequest.decode(value),
    responseSerialize: (value: ListAddressesResponse) => Buffer.from(ListAddressesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ListAddressesResponse.decode(value),
  },
} as const;

export interface AddressServiceServer extends UntypedServiceImplementation {
  createAddress: handleUnaryCall<CreateAddressRequest, AddressResponse>;
  getAddress: handleUnaryCall<GetAddressRequest, AddressResponse>;
  updateAddress: handleUnaryCall<UpdateAddressRequest, AddressResponse>;
  deleteAddress: handleUnaryCall<DeleteAddressRequest, Empty>;
  listAddressesByUser: handleUnaryCall<ListAddressesByUserRequest, ListAddressesResponse>;
}
