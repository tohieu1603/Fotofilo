// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: order.proto

/* eslint-disable */
import { type handleUnaryCall, Metadata, type UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import * as _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";

export const protobufPackage = "order";

/** Enums */
export enum OrderStatus {
  ORDER_STATUS_UNSPECIFIED = 0,
  ORDER_STATUS_PENDING = 1,
  ORDER_STATUS_PROCESSING = 2,
  ORDER_STATUS_SHIPPED = 3,
  ORDER_STATUS_DELIVERED = 4,
  ORDER_STATUS_CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export enum ShippingMethod {
  SHIPPING_METHOD_UNSPECIFIED = 0,
  SHIPPING_METHOD_STANDARD = 1,
  SHIPPING_METHOD_EXPRESS = 2,
  SHIPPING_METHOD_OVERNIGHT = 3,
  UNRECOGNIZED = -1,
}

/** Value Objects */
export interface Money {
  amount: number;
  currency: string;
}

export interface OrderItem {
  productId: string;
  skuId: string;
  skuCode: string;
  quantity: number;
  unitPrice?: Money | undefined;
  discountAmount?: Money | undefined;
  totalAmount?: Money | undefined;
}

/** Request Messages */
export interface CreateOrderRequest {
  /** customer_id lấy từ JWT (api-gateway truyền sang) */
  items: OrderItem[];
  /** lấy từ auth-service */
  shippingAddressId: string;
  /** lấy từ auth-service */
  billingAddressId: string;
  shippingMethod: ShippingMethod;
  notes: string;
  discountAmount?: Money | undefined;
  currency: string;
  paymentMethod: string;
}

export interface GetOrderByIdRequest {
  orderId: string;
}

export interface GetOrderByNumberRequest {
  orderNumber: string;
}

export interface ListOrdersByCustomerRequest {
  /** customer_id lấy từ JWT (api-gateway truyền sang) */
  pageSize: number;
  pageToken: string;
  statusFilter: OrderStatus;
}

export interface UpdateOrderStatusRequest {
  orderId: string;
  status: OrderStatus;
  notes: string;
}

export interface AddOrderTrackingRequest {
  orderId: string;
  trackingNumber: string;
  carrier: string;
}

export interface CancelOrderRequest {
  orderId: string;
  reason: string;
}

/** Response Messages */
export interface OrderDetail {
  id: string;
  productId: string;
  productName: string;
  productSku: string;
  quantity: number;
  unitPrice?: Money | undefined;
  discountAmount?: Money | undefined;
  totalAmount?: Money | undefined;
  productAttributes: { [key: string]: string };
}

export interface OrderDetail_ProductAttributesEntry {
  key: string;
  value: string;
}

export interface OrderResponse {
  id: string;
  customerId: string;
  orderNumber: string;
  status: OrderStatus;
  /** Financial information */
  subtotal?: Money | undefined;
  taxAmount?: Money | undefined;
  shippingAmount?: Money | undefined;
  discountAmount?: Money | undefined;
  totalAmount?:
    | Money
    | undefined;
  /** Payment reference (handled by payment-service) */
  paymentId: string;
  /** Shipping information */
  shippingMethod: ShippingMethod;
  trackingNumber: string;
  shippingAddressId: string;
  billingAddressId: string;
  /** Order details */
  orderDetails: OrderDetail[];
  notes: string;
  /** Timestamps */
  createdAt: string;
  updatedAt: string;
}

export interface OrderListResponse {
  orders: OrderResponse[];
  nextPageToken: string;
  totalCount: number;
}

/** Error Messages */
export interface OrderError {
  code: OrderError_ErrorCode;
  message: string;
  details: { [key: string]: string };
}

export enum OrderError_ErrorCode {
  ERROR_CODE_UNSPECIFIED = 0,
  ERROR_CODE_ORDER_NOT_FOUND = 1,
  ERROR_CODE_INVALID_STATUS_TRANSITION = 2,
  ERROR_CODE_INSUFFICIENT_INVENTORY = 3,
  ERROR_CODE_INVALID_CUSTOMER = 4,
  ERROR_CODE_INVALID_ORDER_ITEMS = 5,
  ERROR_CODE_PAYMENT_REQUIRED = 6,
  UNRECOGNIZED = -1,
}

export interface OrderError_DetailsEntry {
  key: string;
  value: string;
}

export const ORDER_PACKAGE_NAME = "order";

function createBaseMoney(): Money {
  return { amount: 0, currency: "" };
}

export const Money = {
  encode(message: Money, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== 0) {
      writer.uint32(9).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(18).string(message.currency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Money {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoney();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.amount = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currency = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseOrderItem(): OrderItem {
  return { productId: "", skuId: "", skuCode: "", quantity: 0 };
}

export const OrderItem = {
  encode(message: OrderItem, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.skuId !== "") {
      writer.uint32(18).string(message.skuId);
    }
    if (message.skuCode !== "") {
      writer.uint32(26).string(message.skuCode);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    if (message.unitPrice !== undefined) {
      Money.encode(message.unitPrice, writer.uint32(42).fork()).ldelim();
    }
    if (message.discountAmount !== undefined) {
      Money.encode(message.discountAmount, writer.uint32(50).fork()).ldelim();
    }
    if (message.totalAmount !== undefined) {
      Money.encode(message.totalAmount, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderItem {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skuId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.unitPrice = Money.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.discountAmount = Money.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.totalAmount = Money.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreateOrderRequest(): CreateOrderRequest {
  return {
    items: [],
    shippingAddressId: "",
    billingAddressId: "",
    shippingMethod: 0,
    notes: "",
    currency: "",
    paymentMethod: "",
  };
}

export const CreateOrderRequest = {
  encode(message: CreateOrderRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      OrderItem.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.shippingAddressId !== "") {
      writer.uint32(18).string(message.shippingAddressId);
    }
    if (message.billingAddressId !== "") {
      writer.uint32(26).string(message.billingAddressId);
    }
    if (message.shippingMethod !== 0) {
      writer.uint32(32).int32(message.shippingMethod);
    }
    if (message.notes !== "") {
      writer.uint32(42).string(message.notes);
    }
    if (message.discountAmount !== undefined) {
      Money.encode(message.discountAmount, writer.uint32(50).fork()).ldelim();
    }
    if (message.currency !== "") {
      writer.uint32(58).string(message.currency);
    }
    if (message.paymentMethod !== "") {
      writer.uint32(66).string(message.paymentMethod);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateOrderRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(OrderItem.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.shippingAddressId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.billingAddressId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.shippingMethod = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.discountAmount = Money.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.currency = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.paymentMethod = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetOrderByIdRequest(): GetOrderByIdRequest {
  return { orderId: "" };
}

export const GetOrderByIdRequest = {
  encode(message: GetOrderByIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrderByIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetOrderByNumberRequest(): GetOrderByNumberRequest {
  return { orderNumber: "" };
}

export const GetOrderByNumberRequest = {
  encode(message: GetOrderByNumberRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderNumber !== "") {
      writer.uint32(10).string(message.orderNumber);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetOrderByNumberRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderByNumberRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orderNumber = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseListOrdersByCustomerRequest(): ListOrdersByCustomerRequest {
  return { pageSize: 0, pageToken: "", statusFilter: 0 };
}

export const ListOrdersByCustomerRequest = {
  encode(message: ListOrdersByCustomerRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.pageSize !== 0) {
      writer.uint32(8).int32(message.pageSize);
    }
    if (message.pageToken !== "") {
      writer.uint32(18).string(message.pageToken);
    }
    if (message.statusFilter !== 0) {
      writer.uint32(24).int32(message.statusFilter);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListOrdersByCustomerRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListOrdersByCustomerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.pageSize = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.statusFilter = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateOrderStatusRequest(): UpdateOrderStatusRequest {
  return { orderId: "", status: 0, notes: "" };
}

export const UpdateOrderStatusRequest = {
  encode(message: UpdateOrderStatusRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.notes !== "") {
      writer.uint32(26).string(message.notes);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateOrderStatusRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateOrderStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.notes = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAddOrderTrackingRequest(): AddOrderTrackingRequest {
  return { orderId: "", trackingNumber: "", carrier: "" };
}

export const AddOrderTrackingRequest = {
  encode(message: AddOrderTrackingRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.trackingNumber !== "") {
      writer.uint32(18).string(message.trackingNumber);
    }
    if (message.carrier !== "") {
      writer.uint32(26).string(message.carrier);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AddOrderTrackingRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddOrderTrackingRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.trackingNumber = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.carrier = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCancelOrderRequest(): CancelOrderRequest {
  return { orderId: "", reason: "" };
}

export const CancelOrderRequest = {
  encode(message: CancelOrderRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CancelOrderRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseOrderDetail(): OrderDetail {
  return { id: "", productId: "", productName: "", productSku: "", quantity: 0, productAttributes: {} };
}

export const OrderDetail = {
  encode(message: OrderDetail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.productId !== "") {
      writer.uint32(18).string(message.productId);
    }
    if (message.productName !== "") {
      writer.uint32(26).string(message.productName);
    }
    if (message.productSku !== "") {
      writer.uint32(34).string(message.productSku);
    }
    if (message.quantity !== 0) {
      writer.uint32(40).int32(message.quantity);
    }
    if (message.unitPrice !== undefined) {
      Money.encode(message.unitPrice, writer.uint32(50).fork()).ldelim();
    }
    if (message.discountAmount !== undefined) {
      Money.encode(message.discountAmount, writer.uint32(58).fork()).ldelim();
    }
    if (message.totalAmount !== undefined) {
      Money.encode(message.totalAmount, writer.uint32(66).fork()).ldelim();
    }
    Object.entries(message.productAttributes).forEach(([key, value]) => {
      OrderDetail_ProductAttributesEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderDetail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.productName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.productSku = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.unitPrice = Money.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.discountAmount = Money.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.totalAmount = Money.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          const entry9 = OrderDetail_ProductAttributesEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.productAttributes[entry9.key] = entry9.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseOrderDetail_ProductAttributesEntry(): OrderDetail_ProductAttributesEntry {
  return { key: "", value: "" };
}

export const OrderDetail_ProductAttributesEntry = {
  encode(message: OrderDetail_ProductAttributesEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderDetail_ProductAttributesEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderDetail_ProductAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseOrderResponse(): OrderResponse {
  return {
    id: "",
    customerId: "",
    orderNumber: "",
    status: 0,
    paymentId: "",
    shippingMethod: 0,
    trackingNumber: "",
    shippingAddressId: "",
    billingAddressId: "",
    orderDetails: [],
    notes: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const OrderResponse = {
  encode(message: OrderResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.orderNumber !== "") {
      writer.uint32(26).string(message.orderNumber);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.subtotal !== undefined) {
      Money.encode(message.subtotal, writer.uint32(42).fork()).ldelim();
    }
    if (message.taxAmount !== undefined) {
      Money.encode(message.taxAmount, writer.uint32(50).fork()).ldelim();
    }
    if (message.shippingAmount !== undefined) {
      Money.encode(message.shippingAmount, writer.uint32(58).fork()).ldelim();
    }
    if (message.discountAmount !== undefined) {
      Money.encode(message.discountAmount, writer.uint32(66).fork()).ldelim();
    }
    if (message.totalAmount !== undefined) {
      Money.encode(message.totalAmount, writer.uint32(74).fork()).ldelim();
    }
    if (message.paymentId !== "") {
      writer.uint32(82).string(message.paymentId);
    }
    if (message.shippingMethod !== 0) {
      writer.uint32(88).int32(message.shippingMethod);
    }
    if (message.trackingNumber !== "") {
      writer.uint32(98).string(message.trackingNumber);
    }
    if (message.shippingAddressId !== "") {
      writer.uint32(106).string(message.shippingAddressId);
    }
    if (message.billingAddressId !== "") {
      writer.uint32(114).string(message.billingAddressId);
    }
    for (const v of message.orderDetails) {
      OrderDetail.encode(v!, writer.uint32(122).fork()).ldelim();
    }
    if (message.notes !== "") {
      writer.uint32(130).string(message.notes);
    }
    if (message.createdAt !== "") {
      writer.uint32(138).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(146).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.orderNumber = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.subtotal = Money.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.taxAmount = Money.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.shippingAmount = Money.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.discountAmount = Money.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.totalAmount = Money.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.paymentId = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.shippingMethod = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.trackingNumber = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.shippingAddressId = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.billingAddressId = reader.string();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.orderDetails.push(OrderDetail.decode(reader, reader.uint32()));
          continue;
        case 16:
          if (tag !== 130) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 17:
          if (tag !== 138) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseOrderListResponse(): OrderListResponse {
  return { orders: [], nextPageToken: "", totalCount: 0 };
}

export const OrderListResponse = {
  encode(message: OrderListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.orders) {
      OrderResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.nextPageToken !== "") {
      writer.uint32(18).string(message.nextPageToken);
    }
    if (message.totalCount !== 0) {
      writer.uint32(24).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orders.push(OrderResponse.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.nextPageToken = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseOrderError(): OrderError {
  return { code: 0, message: "", details: {} };
}

export const OrderError = {
  encode(message: OrderError, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    Object.entries(message.details).forEach(([key, value]) => {
      OrderError_DetailsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderError {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = OrderError_DetailsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.details[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseOrderError_DetailsEntry(): OrderError_DetailsEntry {
  return { key: "", value: "" };
}

export const OrderError_DetailsEntry = {
  encode(message: OrderError_DetailsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): OrderError_DetailsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderError_DetailsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

/** Order Service - Domain-Driven Design compliant */

export interface OrderServiceClient {
  createOrder(request: CreateOrderRequest, metadata: Metadata, ...rest: any): Observable<OrderResponse>;

  getOrderById(request: GetOrderByIdRequest, metadata: Metadata, ...rest: any): Observable<OrderResponse>;

  getOrderByNumber(request: GetOrderByNumberRequest, metadata: Metadata, ...rest: any): Observable<OrderResponse>;

  listOrdersByCustomer(
    request: ListOrdersByCustomerRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<OrderListResponse>;

  updateOrderStatus(request: UpdateOrderStatusRequest, metadata: Metadata, ...rest: any): Observable<OrderResponse>;

  addOrderTracking(request: AddOrderTrackingRequest, metadata: Metadata, ...rest: any): Observable<OrderResponse>;

  cancelOrder(request: CancelOrderRequest, metadata: Metadata, ...rest: any): Observable<OrderResponse>;
}

/** Order Service - Domain-Driven Design compliant */

export interface OrderServiceController {
  createOrder(
    request: CreateOrderRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<OrderResponse> | Observable<OrderResponse> | OrderResponse;

  getOrderById(
    request: GetOrderByIdRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<OrderResponse> | Observable<OrderResponse> | OrderResponse;

  getOrderByNumber(
    request: GetOrderByNumberRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<OrderResponse> | Observable<OrderResponse> | OrderResponse;

  listOrdersByCustomer(
    request: ListOrdersByCustomerRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<OrderListResponse> | Observable<OrderListResponse> | OrderListResponse;

  updateOrderStatus(
    request: UpdateOrderStatusRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<OrderResponse> | Observable<OrderResponse> | OrderResponse;

  addOrderTracking(
    request: AddOrderTrackingRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<OrderResponse> | Observable<OrderResponse> | OrderResponse;

  cancelOrder(
    request: CancelOrderRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<OrderResponse> | Observable<OrderResponse> | OrderResponse;
}

export function OrderServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createOrder",
      "getOrderById",
      "getOrderByNumber",
      "listOrdersByCustomer",
      "updateOrderStatus",
      "addOrderTracking",
      "cancelOrder",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("OrderService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("OrderService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const ORDER_SERVICE_NAME = "OrderService";

/** Order Service - Domain-Driven Design compliant */
export type OrderServiceService = typeof OrderServiceService;
export const OrderServiceService = {
  createOrder: {
    path: "/order.OrderService/CreateOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateOrderRequest) => Buffer.from(CreateOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateOrderRequest.decode(value),
    responseSerialize: (value: OrderResponse) => Buffer.from(OrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => OrderResponse.decode(value),
  },
  getOrderById: {
    path: "/order.OrderService/GetOrderById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOrderByIdRequest) => Buffer.from(GetOrderByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetOrderByIdRequest.decode(value),
    responseSerialize: (value: OrderResponse) => Buffer.from(OrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => OrderResponse.decode(value),
  },
  getOrderByNumber: {
    path: "/order.OrderService/GetOrderByNumber",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetOrderByNumberRequest) => Buffer.from(GetOrderByNumberRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetOrderByNumberRequest.decode(value),
    responseSerialize: (value: OrderResponse) => Buffer.from(OrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => OrderResponse.decode(value),
  },
  listOrdersByCustomer: {
    path: "/order.OrderService/ListOrdersByCustomer",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListOrdersByCustomerRequest) =>
      Buffer.from(ListOrdersByCustomerRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListOrdersByCustomerRequest.decode(value),
    responseSerialize: (value: OrderListResponse) => Buffer.from(OrderListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => OrderListResponse.decode(value),
  },
  updateOrderStatus: {
    path: "/order.OrderService/UpdateOrderStatus",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateOrderStatusRequest) => Buffer.from(UpdateOrderStatusRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateOrderStatusRequest.decode(value),
    responseSerialize: (value: OrderResponse) => Buffer.from(OrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => OrderResponse.decode(value),
  },
  addOrderTracking: {
    path: "/order.OrderService/AddOrderTracking",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AddOrderTrackingRequest) => Buffer.from(AddOrderTrackingRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AddOrderTrackingRequest.decode(value),
    responseSerialize: (value: OrderResponse) => Buffer.from(OrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => OrderResponse.decode(value),
  },
  cancelOrder: {
    path: "/order.OrderService/CancelOrder",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CancelOrderRequest) => Buffer.from(CancelOrderRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CancelOrderRequest.decode(value),
    responseSerialize: (value: OrderResponse) => Buffer.from(OrderResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => OrderResponse.decode(value),
  },
} as const;

export interface OrderServiceServer extends UntypedServiceImplementation {
  createOrder: handleUnaryCall<CreateOrderRequest, OrderResponse>;
  getOrderById: handleUnaryCall<GetOrderByIdRequest, OrderResponse>;
  getOrderByNumber: handleUnaryCall<GetOrderByNumberRequest, OrderResponse>;
  listOrdersByCustomer: handleUnaryCall<ListOrdersByCustomerRequest, OrderListResponse>;
  updateOrderStatus: handleUnaryCall<UpdateOrderStatusRequest, OrderResponse>;
  addOrderTracking: handleUnaryCall<AddOrderTrackingRequest, OrderResponse>;
  cancelOrder: handleUnaryCall<CancelOrderRequest, OrderResponse>;
}
