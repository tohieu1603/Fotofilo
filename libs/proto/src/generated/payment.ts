// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: payment.proto

/* eslint-disable */
import { type handleUnaryCall, Metadata, type UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import * as _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";
import Long = require("long");

export const protobufPackage = "payment";

export enum PaymentMethod {
  PAYMENT_METHOD_UNSPECIFIED = 0,
  PAYMENT_METHOD_COD = 1,
  PAYMENT_METHOD_MOMO = 2,
  PAYMENT_METHOD_VNPAY = 3,
  PAYMENT_METHOD_STRIPE = 4,
  UNRECOGNIZED = -1,
}

export enum PaymentStatus {
  PAYMENT_STATUS_UNSPECIFIED = 0,
  PAYMENT_STATUS_PENDING = 1,
  PAYMENT_STATUS_PROCESSING = 2,
  PAYMENT_STATUS_SUCCESS = 3,
  PAYMENT_STATUS_FAILED = 4,
  PAYMENT_STATUS_CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export interface Money {
  amount: number;
  currency: string;
}

export interface PaymentResponse {
  id: string;
  orderId: string;
  customerId: string;
  amount?: Money | undefined;
  paymentMethod: PaymentMethod;
  status: PaymentStatus;
  transactionId: string;
  paymentUrl: string;
  notes: string;
  paidAt: string;
  failedAt: string;
  failureReason: string;
  createdAt: string;
  updatedAt: string;
}

export interface CreatePaymentRequest {
  orderId: string;
  customerId: string;
  amount?: Money | undefined;
  paymentMethod: PaymentMethod;
  orderInfo: string;
}

export interface GetPaymentByIdRequest {
  id: string;
}

export interface GetPaymentByOrderIdRequest {
  orderId: string;
}

export interface MoMoCallbackRequest {
  partnerCode: string;
  orderId: string;
  requestId: string;
  amount: number;
  orderInfo: string;
  orderType: string;
  transId: string;
  resultCode: number;
  message: string;
  payType: string;
  responseTime: number;
  extraData: string;
  signature: string;
}

export interface CallbackResponse {
  success: boolean;
  message: string;
}

export const PAYMENT_PACKAGE_NAME = "payment";

function createBaseMoney(): Money {
  return { amount: 0, currency: "" };
}

export const Money = {
  encode(message: Money, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.amount !== 0) {
      writer.uint32(9).double(message.amount);
    }
    if (message.currency !== "") {
      writer.uint32(18).string(message.currency);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Money {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoney();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.amount = reader.double();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.currency = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBasePaymentResponse(): PaymentResponse {
  return {
    id: "",
    orderId: "",
    customerId: "",
    paymentMethod: 0,
    status: 0,
    transactionId: "",
    paymentUrl: "",
    notes: "",
    paidAt: "",
    failedAt: "",
    failureReason: "",
    createdAt: "",
    updatedAt: "",
  };
}

export const PaymentResponse = {
  encode(message: PaymentResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.orderId !== "") {
      writer.uint32(18).string(message.orderId);
    }
    if (message.customerId !== "") {
      writer.uint32(26).string(message.customerId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(34).fork()).ldelim();
    }
    if (message.paymentMethod !== 0) {
      writer.uint32(40).int32(message.paymentMethod);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.transactionId !== "") {
      writer.uint32(58).string(message.transactionId);
    }
    if (message.paymentUrl !== "") {
      writer.uint32(66).string(message.paymentUrl);
    }
    if (message.notes !== "") {
      writer.uint32(74).string(message.notes);
    }
    if (message.paidAt !== "") {
      writer.uint32(82).string(message.paidAt);
    }
    if (message.failedAt !== "") {
      writer.uint32(90).string(message.failedAt);
    }
    if (message.failureReason !== "") {
      writer.uint32(98).string(message.failureReason);
    }
    if (message.createdAt !== "") {
      writer.uint32(106).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(114).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PaymentResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.paymentMethod = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transactionId = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.paymentUrl = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.notes = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.paidAt = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.failedAt = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.failureReason = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePaymentRequest(): CreatePaymentRequest {
  return { orderId: "", customerId: "", paymentMethod: 0, orderInfo: "" };
}

export const CreatePaymentRequest = {
  encode(message: CreatePaymentRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.customerId !== "") {
      writer.uint32(18).string(message.customerId);
    }
    if (message.amount !== undefined) {
      Money.encode(message.amount, writer.uint32(26).fork()).ldelim();
    }
    if (message.paymentMethod !== 0) {
      writer.uint32(32).int32(message.paymentMethod);
    }
    if (message.orderInfo !== "") {
      writer.uint32(42).string(message.orderInfo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePaymentRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePaymentRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.customerId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.amount = Money.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.paymentMethod = reader.int32() as any;
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderInfo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetPaymentByIdRequest(): GetPaymentByIdRequest {
  return { id: "" };
}

export const GetPaymentByIdRequest = {
  encode(message: GetPaymentByIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPaymentByIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetPaymentByOrderIdRequest(): GetPaymentByOrderIdRequest {
  return { orderId: "" };
}

export const GetPaymentByOrderIdRequest = {
  encode(message: GetPaymentByOrderIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetPaymentByOrderIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetPaymentByOrderIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseMoMoCallbackRequest(): MoMoCallbackRequest {
  return {
    partnerCode: "",
    orderId: "",
    requestId: "",
    amount: 0,
    orderInfo: "",
    orderType: "",
    transId: "",
    resultCode: 0,
    message: "",
    payType: "",
    responseTime: 0,
    extraData: "",
    signature: "",
  };
}

export const MoMoCallbackRequest = {
  encode(message: MoMoCallbackRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.partnerCode !== "") {
      writer.uint32(10).string(message.partnerCode);
    }
    if (message.orderId !== "") {
      writer.uint32(18).string(message.orderId);
    }
    if (message.requestId !== "") {
      writer.uint32(26).string(message.requestId);
    }
    if (message.amount !== 0) {
      writer.uint32(32).int64(message.amount);
    }
    if (message.orderInfo !== "") {
      writer.uint32(42).string(message.orderInfo);
    }
    if (message.orderType !== "") {
      writer.uint32(50).string(message.orderType);
    }
    if (message.transId !== "") {
      writer.uint32(58).string(message.transId);
    }
    if (message.resultCode !== 0) {
      writer.uint32(64).int32(message.resultCode);
    }
    if (message.message !== "") {
      writer.uint32(74).string(message.message);
    }
    if (message.payType !== "") {
      writer.uint32(82).string(message.payType);
    }
    if (message.responseTime !== 0) {
      writer.uint32(88).int64(message.responseTime);
    }
    if (message.extraData !== "") {
      writer.uint32(98).string(message.extraData);
    }
    if (message.signature !== "") {
      writer.uint32(106).string(message.signature);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MoMoCallbackRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoMoCallbackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.partnerCode = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.requestId = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.amount = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.orderInfo = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.orderType = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.transId = reader.string();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.resultCode = reader.int32();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.message = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.payType = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.responseTime = longToNumber(reader.int64() as Long);
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.extraData = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.signature = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCallbackResponse(): CallbackResponse {
  return { success: false, message: "" };
}

export const CallbackResponse = {
  encode(message: CallbackResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CallbackResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCallbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

export interface PaymentServiceClient {
  createPayment(request: CreatePaymentRequest, metadata: Metadata, ...rest: any): Observable<PaymentResponse>;

  getPaymentById(request: GetPaymentByIdRequest, metadata: Metadata, ...rest: any): Observable<PaymentResponse>;

  getPaymentByOrderId(
    request: GetPaymentByOrderIdRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<PaymentResponse>;

  handleMoMoCallback(request: MoMoCallbackRequest, metadata: Metadata, ...rest: any): Observable<CallbackResponse>;
}

export interface PaymentServiceController {
  createPayment(
    request: CreatePaymentRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<PaymentResponse> | Observable<PaymentResponse> | PaymentResponse;

  getPaymentById(
    request: GetPaymentByIdRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<PaymentResponse> | Observable<PaymentResponse> | PaymentResponse;

  getPaymentByOrderId(
    request: GetPaymentByOrderIdRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<PaymentResponse> | Observable<PaymentResponse> | PaymentResponse;

  handleMoMoCallback(
    request: MoMoCallbackRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CallbackResponse> | Observable<CallbackResponse> | CallbackResponse;
}

export function PaymentServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = ["createPayment", "getPaymentById", "getPaymentByOrderId", "handleMoMoCallback"];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("PaymentService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("PaymentService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PAYMENT_SERVICE_NAME = "PaymentService";

export type PaymentServiceService = typeof PaymentServiceService;
export const PaymentServiceService = {
  createPayment: {
    path: "/payment.PaymentService/CreatePayment",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePaymentRequest) => Buffer.from(CreatePaymentRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreatePaymentRequest.decode(value),
    responseSerialize: (value: PaymentResponse) => Buffer.from(PaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentResponse.decode(value),
  },
  getPaymentById: {
    path: "/payment.PaymentService/GetPaymentById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPaymentByIdRequest) => Buffer.from(GetPaymentByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPaymentByIdRequest.decode(value),
    responseSerialize: (value: PaymentResponse) => Buffer.from(PaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentResponse.decode(value),
  },
  getPaymentByOrderId: {
    path: "/payment.PaymentService/GetPaymentByOrderId",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetPaymentByOrderIdRequest) =>
      Buffer.from(GetPaymentByOrderIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetPaymentByOrderIdRequest.decode(value),
    responseSerialize: (value: PaymentResponse) => Buffer.from(PaymentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PaymentResponse.decode(value),
  },
  handleMoMoCallback: {
    path: "/payment.PaymentService/HandleMoMoCallback",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MoMoCallbackRequest) => Buffer.from(MoMoCallbackRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MoMoCallbackRequest.decode(value),
    responseSerialize: (value: CallbackResponse) => Buffer.from(CallbackResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CallbackResponse.decode(value),
  },
} as const;

export interface PaymentServiceServer extends UntypedServiceImplementation {
  createPayment: handleUnaryCall<CreatePaymentRequest, PaymentResponse>;
  getPaymentById: handleUnaryCall<GetPaymentByIdRequest, PaymentResponse>;
  getPaymentByOrderId: handleUnaryCall<GetPaymentByOrderIdRequest, PaymentResponse>;
  handleMoMoCallback: handleUnaryCall<MoMoCallbackRequest, CallbackResponse>;
}

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}
