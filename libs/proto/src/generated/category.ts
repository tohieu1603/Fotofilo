// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: category.proto

/* eslint-disable */
import { type handleUnaryCall, Metadata, type UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import * as _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";

export const protobufPackage = "category";

export interface Category {
  id: string;
  name: string;
  slug: string;
  image: string;
  active: boolean;
  parentId: string;
  deletedAt: string;
  children: Category[];
}

export interface CreateCategoryRequest {
  name: string;
  slug: string;
  image: string;
  active: boolean;
  parentId: string;
}

export interface UpdateCategoryRequest {
  id: string;
  name: string;
  slug: string;
  image: string;
  active: boolean;
  parentId: string;
}

export interface DeleteCategoryRequest {
  id: string;
}

export interface GetCategoryRequest {
  id: string;
}

export interface ListCategoriesRequest {
  keyword: string;
  active: boolean;
  page: number;
  limit: number;
}

export interface CategoryResponse {
  id: string;
  name: string;
  slug: string;
  image: string;
  active: boolean;
  parentId: string;
}

export interface CategoryListResponse {
  categories: Category[];
  total: number;
}

export const CATEGORY_PACKAGE_NAME = "category";

function createBaseCategory(): Category {
  return { id: "", name: "", slug: "", image: "", active: false, parentId: "", deletedAt: "", children: [] };
}

export const Category = {
  encode(message: Category, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(26).string(message.slug);
    }
    if (message.image !== "") {
      writer.uint32(34).string(message.image);
    }
    if (message.active !== false) {
      writer.uint32(40).bool(message.active);
    }
    if (message.parentId !== "") {
      writer.uint32(50).string(message.parentId);
    }
    if (message.deletedAt !== "") {
      writer.uint32(58).string(message.deletedAt);
    }
    for (const v of message.children) {
      Category.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Category {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.slug = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.image = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.active = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.parentId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.deletedAt = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.children.push(Category.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreateCategoryRequest(): CreateCategoryRequest {
  return { name: "", slug: "", image: "", active: false, parentId: "" };
}

export const CreateCategoryRequest = {
  encode(message: CreateCategoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(18).string(message.slug);
    }
    if (message.image !== "") {
      writer.uint32(26).string(message.image);
    }
    if (message.active !== false) {
      writer.uint32(32).bool(message.active);
    }
    if (message.parentId !== "") {
      writer.uint32(42).string(message.parentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateCategoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.slug = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.image = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.active = reader.bool();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.parentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateCategoryRequest(): UpdateCategoryRequest {
  return { id: "", name: "", slug: "", image: "", active: false, parentId: "" };
}

export const UpdateCategoryRequest = {
  encode(message: UpdateCategoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(26).string(message.slug);
    }
    if (message.image !== "") {
      writer.uint32(34).string(message.image);
    }
    if (message.active !== false) {
      writer.uint32(40).bool(message.active);
    }
    if (message.parentId !== "") {
      writer.uint32(50).string(message.parentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateCategoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.slug = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.image = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.active = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.parentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteCategoryRequest(): DeleteCategoryRequest {
  return { id: "" };
}

export const DeleteCategoryRequest = {
  encode(message: DeleteCategoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteCategoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetCategoryRequest(): GetCategoryRequest {
  return { id: "" };
}

export const GetCategoryRequest = {
  encode(message: GetCategoryRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetCategoryRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCategoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseListCategoriesRequest(): ListCategoriesRequest {
  return { keyword: "", active: false, page: 0, limit: 0 };
}

export const ListCategoriesRequest = {
  encode(message: ListCategoriesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.keyword !== "") {
      writer.uint32(26).string(message.keyword);
    }
    if (message.active !== false) {
      writer.uint32(32).bool(message.active);
    }
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListCategoriesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListCategoriesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keyword = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.active = reader.bool();
          continue;
        case 1:
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCategoryResponse(): CategoryResponse {
  return { id: "", name: "", slug: "", image: "", active: false, parentId: "" };
}

export const CategoryResponse = {
  encode(message: CategoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(26).string(message.slug);
    }
    if (message.image !== "") {
      writer.uint32(34).string(message.image);
    }
    if (message.active !== false) {
      writer.uint32(40).bool(message.active);
    }
    if (message.parentId !== "") {
      writer.uint32(50).string(message.parentId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CategoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.slug = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.image = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.active = reader.bool();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.parentId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCategoryListResponse(): CategoryListResponse {
  return { categories: [], total: 0 };
}

export const CategoryListResponse = {
  encode(message: CategoryListResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.categories) {
      Category.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CategoryListResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryListResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.categories.push(Category.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

export interface CategoryServiceClient {
  createCategory(request: CreateCategoryRequest, metadata: Metadata, ...rest: any): Observable<CategoryResponse>;

  updateCategory(request: UpdateCategoryRequest, metadata: Metadata, ...rest: any): Observable<CategoryResponse>;

  deleteCategory(request: DeleteCategoryRequest, metadata: Metadata, ...rest: any): Observable<CategoryResponse>;

  getCategory(request: GetCategoryRequest, metadata: Metadata, ...rest: any): Observable<CategoryResponse>;

  listCategories(request: ListCategoriesRequest, metadata: Metadata, ...rest: any): Observable<CategoryListResponse>;
}

export interface CategoryServiceController {
  createCategory(
    request: CreateCategoryRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CategoryResponse> | Observable<CategoryResponse> | CategoryResponse;

  updateCategory(
    request: UpdateCategoryRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CategoryResponse> | Observable<CategoryResponse> | CategoryResponse;

  deleteCategory(
    request: DeleteCategoryRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CategoryResponse> | Observable<CategoryResponse> | CategoryResponse;

  getCategory(
    request: GetCategoryRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CategoryResponse> | Observable<CategoryResponse> | CategoryResponse;

  listCategories(
    request: ListCategoriesRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CategoryListResponse> | Observable<CategoryListResponse> | CategoryListResponse;
}

export function CategoryServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createCategory",
      "updateCategory",
      "deleteCategory",
      "getCategory",
      "listCategories",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("CategoryService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("CategoryService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const CATEGORY_SERVICE_NAME = "CategoryService";

export type CategoryServiceService = typeof CategoryServiceService;
export const CategoryServiceService = {
  createCategory: {
    path: "/category.CategoryService/CreateCategory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateCategoryRequest) => Buffer.from(CreateCategoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateCategoryRequest.decode(value),
    responseSerialize: (value: CategoryResponse) => Buffer.from(CategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CategoryResponse.decode(value),
  },
  updateCategory: {
    path: "/category.CategoryService/UpdateCategory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateCategoryRequest) => Buffer.from(UpdateCategoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateCategoryRequest.decode(value),
    responseSerialize: (value: CategoryResponse) => Buffer.from(CategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CategoryResponse.decode(value),
  },
  deleteCategory: {
    path: "/category.CategoryService/DeleteCategory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteCategoryRequest) => Buffer.from(DeleteCategoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteCategoryRequest.decode(value),
    responseSerialize: (value: CategoryResponse) => Buffer.from(CategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CategoryResponse.decode(value),
  },
  getCategory: {
    path: "/category.CategoryService/GetCategory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetCategoryRequest) => Buffer.from(GetCategoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetCategoryRequest.decode(value),
    responseSerialize: (value: CategoryResponse) => Buffer.from(CategoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CategoryResponse.decode(value),
  },
  listCategories: {
    path: "/category.CategoryService/ListCategories",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListCategoriesRequest) => Buffer.from(ListCategoriesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ListCategoriesRequest.decode(value),
    responseSerialize: (value: CategoryListResponse) => Buffer.from(CategoryListResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CategoryListResponse.decode(value),
  },
} as const;

export interface CategoryServiceServer extends UntypedServiceImplementation {
  createCategory: handleUnaryCall<CreateCategoryRequest, CategoryResponse>;
  updateCategory: handleUnaryCall<UpdateCategoryRequest, CategoryResponse>;
  deleteCategory: handleUnaryCall<DeleteCategoryRequest, CategoryResponse>;
  getCategory: handleUnaryCall<GetCategoryRequest, CategoryResponse>;
  listCategories: handleUnaryCall<ListCategoriesRequest, CategoryListResponse>;
}
