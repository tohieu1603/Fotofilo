// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: product.proto

/* eslint-disable */
import { type handleUnaryCall, Metadata, type UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import * as _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";

export const protobufPackage = "product";

/** ======================= Enums ======================= */
export enum SortField {
  SORT_FIELD_UNSPECIFIED = 0,
  SORT_FIELD_NAME = 1,
  SORT_FIELD_PRICE = 2,
  SORT_FIELD_CREATED_AT = 3,
  UNRECOGNIZED = -1,
}

export enum SortOrder {
  SORT_ORDER_UNSPECIFIED = 0,
  SORT_ORDER_ASC = 1,
  SORT_ORDER_DESC = 2,
  UNRECOGNIZED = -1,
}

/** ======================= Attribute ======================= */
export interface GetAttributesRequest {
}

export interface GetAttributesResponse {
  attributes: AttributeDetail[];
}

export interface GetAttributeOptionsRequest {
  attributeId: string;
}

export interface GetAttributeOptionsResponse {
  attributeId: string;
  attributeName: string;
  options: AttributeOption[];
}

export interface AttributeOption {
  id: string;
  value: string;
  description: string;
}

export interface AttributeDetail {
  id: string;
  name: string;
  description: string;
}

/** ======================= Brand & Category ======================= */
export interface BrandResponse {
  id: string;
  name: string;
}

export interface CategoryResponse {
  id: string;
  name: string;
  slug: string;
}

/** ======================= SKU ======================= */
export interface SkuResponse {
  id: string;
  skuCode: string;
  price: number;
  stock: number;
  image: string;
  skuOptions: SkuOptionResponse[];
  originalPrice: number;
}

export interface SkuOptionResponse {
  attributeOptionId: string;
  attributeOptionValue: string;
  attribute?: AttributeDetail | undefined;
}

/** ======================= Product CRUD ======================= */
export interface CreateProductRequest {
  name: string;
  description: string;
  brandId: string;
  categoryId: string;
  skus: CreateSkuInput[];
  originalPrice: number;
}

export interface CreateSkuInput {
  skuCode: string;
  price: number;
  stock: number;
  image: string;
  attributes: AttributeInput[];
}

export interface AttributeInput {
  attributeOptionId: string;
}

export interface CreateProductResponse {
  product?: GetProductResponse | undefined;
}

export interface GetProductRequest {
  id: string;
  userId?: string | undefined;
}

export interface GetProductResponse {
  id: string;
  name: string;
  description: string;
  brand?: BrandResponse | undefined;
  category?: CategoryResponse | undefined;
  skus: SkuResponse[];
  originalPrice: number;
}

export interface GetProductSkuRequest {
  id: string;
}

export interface GetProductSkuResponse {
  id: string;
  name: string;
  description: string;
  brand?: BrandResponse | undefined;
  category?: CategoryResponse | undefined;
  skus: SkuResponse[];
}

export interface UpdateProductRequest {
  id: string;
  name: string;
  description: string;
  brandId: string;
  categoryId: string;
  skus: CreateSkuInput[];
  originalPrice: number;
}

export interface UpdateProductResponse {
  product?: GetProductResponse | undefined;
}

export interface DeleteProductRequest {
  id: string;
}

export interface DeleteProductResponse {
  message: boolean;
}

export interface GetAllProductsRequest {
  page: number;
  limit: number;
  keyword: string;
  brandId: string;
  categoryId: string;
  sortField: SortField;
  sortOrder: SortOrder;
  minPrice?: number | undefined;
  maxPrice?: number | undefined;
}

export interface GetAllProductsResponse {
  products: GetProductResponse[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

/** ======================= SKU Validation ======================= */
export interface SkuValidationInput {
  productId: string;
  skuId: string;
  skuCode: string;
  quantity: number;
}

export interface ValidateSkuInputRequest {
  items: SkuValidationInput[];
}

export interface SkuValidationResult {
  productId: string;
  name: string;
  description: string;
  brand?: BrandResponse | undefined;
  category?: CategoryResponse | undefined;
  skuId: string;
  skuCode: string;
  price: number;
  stock: number;
  image: string;
  skuOptions: SkuOptionResponse[];
  valid: boolean;
  inStock: boolean;
  availableStock: number;
  message: string;
}

export interface ValidateSkuInputResponse {
  allValid: boolean;
  results: SkuValidationResult[];
}

/** ======================= SKU Availability ======================= */
export interface CheckSkuAvailabilityRequest {
  skuId: string;
  quantity: number;
}

export interface CheckSkuAvailabilityResponse {
  exists: boolean;
  inStock: boolean;
  availableStock: number;
  message: string;
  productId: string;
  skuCode: string;
  price: number;
  productName: string;
  description: string;
  image: string;
  brand?: BrandResponse | undefined;
  category?: CategoryResponse | undefined;
  skuOptions: SkuOptionResponse[];
}

export const PRODUCT_PACKAGE_NAME = "product";

function createBaseGetAttributesRequest(): GetAttributesRequest {
  return {};
}

export const GetAttributesRequest = {
  encode(_: GetAttributesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAttributesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAttributesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAttributesResponse(): GetAttributesResponse {
  return { attributes: [] };
}

export const GetAttributesResponse = {
  encode(message: GetAttributesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.attributes) {
      AttributeDetail.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAttributesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAttributesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributes.push(AttributeDetail.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAttributeOptionsRequest(): GetAttributeOptionsRequest {
  return { attributeId: "" };
}

export const GetAttributeOptionsRequest = {
  encode(message: GetAttributeOptionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.attributeId !== "") {
      writer.uint32(10).string(message.attributeId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAttributeOptionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAttributeOptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAttributeOptionsResponse(): GetAttributeOptionsResponse {
  return { attributeId: "", attributeName: "", options: [] };
}

export const GetAttributeOptionsResponse = {
  encode(message: GetAttributeOptionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.attributeId !== "") {
      writer.uint32(10).string(message.attributeId);
    }
    if (message.attributeName !== "") {
      writer.uint32(18).string(message.attributeName);
    }
    for (const v of message.options) {
      AttributeOption.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAttributeOptionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAttributeOptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributeName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.options.push(AttributeOption.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAttributeOption(): AttributeOption {
  return { id: "", value: "", description: "" };
}

export const AttributeOption = {
  encode(message: AttributeOption, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttributeOption {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAttributeDetail(): AttributeDetail {
  return { id: "", name: "", description: "" };
}

export const AttributeDetail = {
  encode(message: AttributeDetail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttributeDetail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseBrandResponse(): BrandResponse {
  return { id: "", name: "" };
}

export const BrandResponse = {
  encode(message: BrandResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BrandResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCategoryResponse(): CategoryResponse {
  return { id: "", name: "", slug: "" };
}

export const CategoryResponse = {
  encode(message: CategoryResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.slug !== "") {
      writer.uint32(26).string(message.slug);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CategoryResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCategoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.slug = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseSkuResponse(): SkuResponse {
  return { id: "", skuCode: "", price: 0, stock: 0, image: "", skuOptions: [], originalPrice: 0 };
}

export const SkuResponse = {
  encode(message: SkuResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.skuCode !== "") {
      writer.uint32(18).string(message.skuCode);
    }
    if (message.price !== 0) {
      writer.uint32(25).double(message.price);
    }
    if (message.stock !== 0) {
      writer.uint32(32).int32(message.stock);
    }
    if (message.image !== "") {
      writer.uint32(42).string(message.image);
    }
    for (const v of message.skuOptions) {
      SkuOptionResponse.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.originalPrice !== 0) {
      writer.uint32(57).double(message.originalPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SkuResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.price = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.stock = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.image = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skuOptions.push(SkuOptionResponse.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.originalPrice = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseSkuOptionResponse(): SkuOptionResponse {
  return { attributeOptionId: "", attributeOptionValue: "" };
}

export const SkuOptionResponse = {
  encode(message: SkuOptionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.attributeOptionId !== "") {
      writer.uint32(10).string(message.attributeOptionId);
    }
    if (message.attributeOptionValue !== "") {
      writer.uint32(18).string(message.attributeOptionValue);
    }
    if (message.attribute !== undefined) {
      AttributeDetail.encode(message.attribute, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SkuOptionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuOptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeOptionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributeOptionValue = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.attribute = AttributeDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreateProductRequest(): CreateProductRequest {
  return { name: "", description: "", brandId: "", categoryId: "", skus: [], originalPrice: 0 };
}

export const CreateProductRequest = {
  encode(message: CreateProductRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.brandId !== "") {
      writer.uint32(26).string(message.brandId);
    }
    if (message.categoryId !== "") {
      writer.uint32(34).string(message.categoryId);
    }
    for (const v of message.skus) {
      CreateSkuInput.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    if (message.originalPrice !== 0) {
      writer.uint32(49).double(message.originalPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateProductRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.brandId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.skus.push(CreateSkuInput.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.originalPrice = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreateSkuInput(): CreateSkuInput {
  return { skuCode: "", price: 0, stock: 0, image: "", attributes: [] };
}

export const CreateSkuInput = {
  encode(message: CreateSkuInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skuCode !== "") {
      writer.uint32(10).string(message.skuCode);
    }
    if (message.price !== 0) {
      writer.uint32(17).double(message.price);
    }
    if (message.stock !== 0) {
      writer.uint32(24).int32(message.stock);
    }
    if (message.image !== "") {
      writer.uint32(34).string(message.image);
    }
    for (const v of message.attributes) {
      AttributeInput.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSkuInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSkuInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.price = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.stock = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.image = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.attributes.push(AttributeInput.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAttributeInput(): AttributeInput {
  return { attributeOptionId: "" };
}

export const AttributeInput = {
  encode(message: AttributeInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.attributeOptionId !== "") {
      writer.uint32(10).string(message.attributeOptionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttributeInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeOptionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreateProductResponse(): CreateProductResponse {
  return {};
}

export const CreateProductResponse = {
  encode(message: CreateProductResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.product !== undefined) {
      GetProductResponse.encode(message.product, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateProductResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.product = GetProductResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetProductRequest(): GetProductRequest {
  return { id: "" };
}

export const GetProductRequest = {
  encode(message: GetProductRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== undefined) {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProductRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetProductResponse(): GetProductResponse {
  return { id: "", name: "", description: "", skus: [], originalPrice: 0 };
}

export const GetProductResponse = {
  encode(message: GetProductResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.brand !== undefined) {
      BrandResponse.encode(message.brand, writer.uint32(34).fork()).ldelim();
    }
    if (message.category !== undefined) {
      CategoryResponse.encode(message.category, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.skus) {
      SkuResponse.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.originalPrice !== 0) {
      writer.uint32(57).double(message.originalPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProductResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.brand = BrandResponse.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.category = CategoryResponse.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skus.push(SkuResponse.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.originalPrice = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetProductSkuRequest(): GetProductSkuRequest {
  return { id: "" };
}

export const GetProductSkuRequest = {
  encode(message: GetProductSkuRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProductSkuRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductSkuRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetProductSkuResponse(): GetProductSkuResponse {
  return { id: "", name: "", description: "", skus: [] };
}

export const GetProductSkuResponse = {
  encode(message: GetProductSkuResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.brand !== undefined) {
      BrandResponse.encode(message.brand, writer.uint32(34).fork()).ldelim();
    }
    if (message.category !== undefined) {
      CategoryResponse.encode(message.category, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.skus) {
      SkuResponse.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProductSkuResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductSkuResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.brand = BrandResponse.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.category = CategoryResponse.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skus.push(SkuResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateProductRequest(): UpdateProductRequest {
  return { id: "", name: "", description: "", brandId: "", categoryId: "", skus: [], originalPrice: 0 };
}

export const UpdateProductRequest = {
  encode(message: UpdateProductRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.brandId !== "") {
      writer.uint32(34).string(message.brandId);
    }
    if (message.categoryId !== "") {
      writer.uint32(42).string(message.categoryId);
    }
    for (const v of message.skus) {
      CreateSkuInput.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    if (message.originalPrice !== 0) {
      writer.uint32(57).double(message.originalPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateProductRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.brandId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skus.push(CreateSkuInput.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.originalPrice = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateProductResponse(): UpdateProductResponse {
  return {};
}

export const UpdateProductResponse = {
  encode(message: UpdateProductResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.product !== undefined) {
      GetProductResponse.encode(message.product, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateProductResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.product = GetProductResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteProductRequest(): DeleteProductRequest {
  return { id: "" };
}

export const DeleteProductRequest = {
  encode(message: DeleteProductRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProductRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteProductResponse(): DeleteProductResponse {
  return { message: false };
}

export const DeleteProductResponse = {
  encode(message: DeleteProductResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== false) {
      writer.uint32(8).bool(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProductResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.message = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAllProductsRequest(): GetAllProductsRequest {
  return { page: 0, limit: 0, keyword: "", brandId: "", categoryId: "", sortField: 0, sortOrder: 0 };
}

export const GetAllProductsRequest = {
  encode(message: GetAllProductsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.keyword !== "") {
      writer.uint32(26).string(message.keyword);
    }
    if (message.brandId !== "") {
      writer.uint32(34).string(message.brandId);
    }
    if (message.categoryId !== "") {
      writer.uint32(42).string(message.categoryId);
    }
    if (message.sortField !== 0) {
      writer.uint32(48).int32(message.sortField);
    }
    if (message.sortOrder !== 0) {
      writer.uint32(56).int32(message.sortOrder);
    }
    if (message.minPrice !== undefined) {
      writer.uint32(65).double(message.minPrice);
    }
    if (message.maxPrice !== undefined) {
      writer.uint32(73).double(message.maxPrice);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllProductsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keyword = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.brandId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.sortField = reader.int32() as any;
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.sortOrder = reader.int32() as any;
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.minPrice = reader.double();
          continue;
        case 9:
          if (tag !== 73) {
            break;
          }

          message.maxPrice = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAllProductsResponse(): GetAllProductsResponse {
  return { products: [], total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const GetAllProductsResponse = {
  encode(message: GetAllProductsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.products) {
      GetProductResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(40).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllProductsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.products.push(GetProductResponse.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseSkuValidationInput(): SkuValidationInput {
  return { productId: "", skuId: "", skuCode: "", quantity: 0 };
}

export const SkuValidationInput = {
  encode(message: SkuValidationInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.skuId !== "") {
      writer.uint32(18).string(message.skuId);
    }
    if (message.skuCode !== "") {
      writer.uint32(26).string(message.skuCode);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SkuValidationInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuValidationInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skuId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseValidateSkuInputRequest(): ValidateSkuInputRequest {
  return { items: [] };
}

export const ValidateSkuInputRequest = {
  encode(message: ValidateSkuInputRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      SkuValidationInput.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ValidateSkuInputRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateSkuInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(SkuValidationInput.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseSkuValidationResult(): SkuValidationResult {
  return {
    productId: "",
    name: "",
    description: "",
    skuId: "",
    skuCode: "",
    price: 0,
    stock: 0,
    image: "",
    skuOptions: [],
    valid: false,
    inStock: false,
    availableStock: 0,
    message: "",
  };
}

export const SkuValidationResult = {
  encode(message: SkuValidationResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.brand !== undefined) {
      BrandResponse.encode(message.brand, writer.uint32(34).fork()).ldelim();
    }
    if (message.category !== undefined) {
      CategoryResponse.encode(message.category, writer.uint32(42).fork()).ldelim();
    }
    if (message.skuId !== "") {
      writer.uint32(50).string(message.skuId);
    }
    if (message.skuCode !== "") {
      writer.uint32(58).string(message.skuCode);
    }
    if (message.price !== 0) {
      writer.uint32(65).double(message.price);
    }
    if (message.stock !== 0) {
      writer.uint32(72).int32(message.stock);
    }
    if (message.image !== "") {
      writer.uint32(82).string(message.image);
    }
    for (const v of message.skuOptions) {
      SkuOptionResponse.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.valid !== false) {
      writer.uint32(96).bool(message.valid);
    }
    if (message.inStock !== false) {
      writer.uint32(104).bool(message.inStock);
    }
    if (message.availableStock !== 0) {
      writer.uint32(112).int32(message.availableStock);
    }
    if (message.message !== "") {
      writer.uint32(122).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SkuValidationResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuValidationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.brand = BrandResponse.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.category = CategoryResponse.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skuId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.price = reader.double();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.stock = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.image = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.skuOptions.push(SkuOptionResponse.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.valid = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.inStock = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.availableStock = reader.int32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseValidateSkuInputResponse(): ValidateSkuInputResponse {
  return { allValid: false, results: [] };
}

export const ValidateSkuInputResponse = {
  encode(message: ValidateSkuInputResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.allValid !== false) {
      writer.uint32(8).bool(message.allValid);
    }
    for (const v of message.results) {
      SkuValidationResult.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ValidateSkuInputResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateSkuInputResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.allValid = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(SkuValidationResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCheckSkuAvailabilityRequest(): CheckSkuAvailabilityRequest {
  return { skuId: "", quantity: 0 };
}

export const CheckSkuAvailabilityRequest = {
  encode(message: CheckSkuAvailabilityRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skuId !== "") {
      writer.uint32(10).string(message.skuId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckSkuAvailabilityRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckSkuAvailabilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCheckSkuAvailabilityResponse(): CheckSkuAvailabilityResponse {
  return {
    exists: false,
    inStock: false,
    availableStock: 0,
    message: "",
    productId: "",
    skuCode: "",
    price: 0,
    productName: "",
    description: "",
    image: "",
    skuOptions: [],
  };
}

export const CheckSkuAvailabilityResponse = {
  encode(message: CheckSkuAvailabilityResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    if (message.inStock !== false) {
      writer.uint32(16).bool(message.inStock);
    }
    if (message.availableStock !== 0) {
      writer.uint32(24).int32(message.availableStock);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.productId !== "") {
      writer.uint32(42).string(message.productId);
    }
    if (message.skuCode !== "") {
      writer.uint32(50).string(message.skuCode);
    }
    if (message.price !== 0) {
      writer.uint32(57).double(message.price);
    }
    if (message.productName !== "") {
      writer.uint32(66).string(message.productName);
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.image !== "") {
      writer.uint32(82).string(message.image);
    }
    if (message.brand !== undefined) {
      BrandResponse.encode(message.brand, writer.uint32(90).fork()).ldelim();
    }
    if (message.category !== undefined) {
      CategoryResponse.encode(message.category, writer.uint32(98).fork()).ldelim();
    }
    for (const v of message.skuOptions) {
      SkuOptionResponse.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckSkuAvailabilityResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckSkuAvailabilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.exists = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.inStock = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.availableStock = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.price = reader.double();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.productName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.image = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.brand = BrandResponse.decode(reader, reader.uint32());
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.category = CategoryResponse.decode(reader, reader.uint32());
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.skuOptions.push(SkuOptionResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

export interface ProductServiceClient {
  createProduct(request: CreateProductRequest, metadata: Metadata, ...rest: any): Observable<CreateProductResponse>;

  getProduct(request: GetProductRequest, metadata: Metadata, ...rest: any): Observable<GetProductResponse>;

  getProducts(request: GetAllProductsRequest, metadata: Metadata, ...rest: any): Observable<GetAllProductsResponse>;

  validateSkuInputs(
    request: ValidateSkuInputRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<ValidateSkuInputResponse>;

  updateProduct(request: UpdateProductRequest, metadata: Metadata, ...rest: any): Observable<UpdateProductResponse>;

  deleteProduct(request: DeleteProductRequest, metadata: Metadata, ...rest: any): Observable<DeleteProductResponse>;

  existingSku(
    request: CheckSkuAvailabilityRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<CheckSkuAvailabilityResponse>;

  getAttributes(request: GetAttributesRequest, metadata: Metadata, ...rest: any): Observable<GetAttributesResponse>;

  getAttributeOptions(
    request: GetAttributeOptionsRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<GetAttributeOptionsResponse>;
}

export interface ProductServiceController {
  createProduct(
    request: CreateProductRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CreateProductResponse> | Observable<CreateProductResponse> | CreateProductResponse;

  getProduct(
    request: GetProductRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetProductResponse> | Observable<GetProductResponse> | GetProductResponse;

  getProducts(
    request: GetAllProductsRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetAllProductsResponse> | Observable<GetAllProductsResponse> | GetAllProductsResponse;

  validateSkuInputs(
    request: ValidateSkuInputRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<ValidateSkuInputResponse> | Observable<ValidateSkuInputResponse> | ValidateSkuInputResponse;

  updateProduct(
    request: UpdateProductRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<UpdateProductResponse> | Observable<UpdateProductResponse> | UpdateProductResponse;

  deleteProduct(
    request: DeleteProductRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<DeleteProductResponse> | Observable<DeleteProductResponse> | DeleteProductResponse;

  existingSku(
    request: CheckSkuAvailabilityRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CheckSkuAvailabilityResponse> | Observable<CheckSkuAvailabilityResponse> | CheckSkuAvailabilityResponse;

  getAttributes(
    request: GetAttributesRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetAttributesResponse> | Observable<GetAttributesResponse> | GetAttributesResponse;

  getAttributeOptions(
    request: GetAttributeOptionsRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetAttributeOptionsResponse> | Observable<GetAttributeOptionsResponse> | GetAttributeOptionsResponse;
}

export function ProductServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createProduct",
      "getProduct",
      "getProducts",
      "validateSkuInputs",
      "updateProduct",
      "deleteProduct",
      "existingSku",
      "getAttributes",
      "getAttributeOptions",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ProductService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ProductService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PRODUCT_SERVICE_NAME = "ProductService";

export type ProductServiceService = typeof ProductServiceService;
export const ProductServiceService = {
  createProduct: {
    path: "/product.ProductService/CreateProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProductRequest) => Buffer.from(CreateProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateProductRequest.decode(value),
    responseSerialize: (value: CreateProductResponse) => Buffer.from(CreateProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateProductResponse.decode(value),
  },
  getProduct: {
    path: "/product.ProductService/GetProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProductRequest) => Buffer.from(GetProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetProductRequest.decode(value),
    responseSerialize: (value: GetProductResponse) => Buffer.from(GetProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetProductResponse.decode(value),
  },
  getProducts: {
    path: "/product.ProductService/GetProducts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllProductsRequest) => Buffer.from(GetAllProductsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllProductsRequest.decode(value),
    responseSerialize: (value: GetAllProductsResponse) => Buffer.from(GetAllProductsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllProductsResponse.decode(value),
  },
  validateSkuInputs: {
    path: "/product.ProductService/ValidateSkuInputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateSkuInputRequest) => Buffer.from(ValidateSkuInputRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ValidateSkuInputRequest.decode(value),
    responseSerialize: (value: ValidateSkuInputResponse) =>
      Buffer.from(ValidateSkuInputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValidateSkuInputResponse.decode(value),
  },
  updateProduct: {
    path: "/product.ProductService/UpdateProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProductRequest) => Buffer.from(UpdateProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateProductRequest.decode(value),
    responseSerialize: (value: UpdateProductResponse) => Buffer.from(UpdateProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateProductResponse.decode(value),
  },
  deleteProduct: {
    path: "/product.ProductService/DeleteProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteProductRequest) => Buffer.from(DeleteProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteProductRequest.decode(value),
    responseSerialize: (value: DeleteProductResponse) => Buffer.from(DeleteProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteProductResponse.decode(value),
  },
  existingSku: {
    path: "/product.ProductService/existingSku",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckSkuAvailabilityRequest) =>
      Buffer.from(CheckSkuAvailabilityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CheckSkuAvailabilityRequest.decode(value),
    responseSerialize: (value: CheckSkuAvailabilityResponse) =>
      Buffer.from(CheckSkuAvailabilityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckSkuAvailabilityResponse.decode(value),
  },
  getAttributes: {
    path: "/product.ProductService/GetAttributes",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAttributesRequest) => Buffer.from(GetAttributesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAttributesRequest.decode(value),
    responseSerialize: (value: GetAttributesResponse) => Buffer.from(GetAttributesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAttributesResponse.decode(value),
  },
  getAttributeOptions: {
    path: "/product.ProductService/GetAttributeOptions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAttributeOptionsRequest) =>
      Buffer.from(GetAttributeOptionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAttributeOptionsRequest.decode(value),
    responseSerialize: (value: GetAttributeOptionsResponse) =>
      Buffer.from(GetAttributeOptionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAttributeOptionsResponse.decode(value),
  },
} as const;

export interface ProductServiceServer extends UntypedServiceImplementation {
  createProduct: handleUnaryCall<CreateProductRequest, CreateProductResponse>;
  getProduct: handleUnaryCall<GetProductRequest, GetProductResponse>;
  getProducts: handleUnaryCall<GetAllProductsRequest, GetAllProductsResponse>;
  validateSkuInputs: handleUnaryCall<ValidateSkuInputRequest, ValidateSkuInputResponse>;
  updateProduct: handleUnaryCall<UpdateProductRequest, UpdateProductResponse>;
  deleteProduct: handleUnaryCall<DeleteProductRequest, DeleteProductResponse>;
  existingSku: handleUnaryCall<CheckSkuAvailabilityRequest, CheckSkuAvailabilityResponse>;
  getAttributes: handleUnaryCall<GetAttributesRequest, GetAttributesResponse>;
  getAttributeOptions: handleUnaryCall<GetAttributeOptionsRequest, GetAttributeOptionsResponse>;
}
