// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: product.proto

/* eslint-disable */
import { type handleUnaryCall, Metadata, type UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import * as _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";

export const protobufPackage = "product";

export interface CheckSkuAvailabilityRequest {
  skuId: string;
  quantity: number;
}

export interface CheckSkuAvailabilityResponse {
  exists: boolean;
  inStock: boolean;
  availableStock: number;
  message: string;
  productId: string;
  skuCode: string;
  price: number;
  productName: string;
  description: string;
  image: string;
  brandId: string;
  categoryId: string;
  skuOptions: SkuOptionResponse[];
}

/** ======================= Create Product ======================= */
export interface CreateProductRequest {
  name: string;
  description: string;
  brandId: string;
  categoryId: string;
  skus: CreateSkuInput[];
}

export interface CreateSkuInput {
  skuCode: string;
  price: number;
  stock: number;
  image: string;
  attributes: AttributeInput[];
}

export interface AttributeInput {
  attributeOptionId: string;
}

export interface CreateProductResponse {
  product?: GetProductResponse | undefined;
}

/** ======================= Get Product ======================= */
export interface GetProductRequest {
  id: string;
  userId?: string | undefined;
}

export interface GetProductResponse {
  id: string;
  name: string;
  description: string;
  brandId: string;
  categoryId: string;
  skus: SkuResponse[];
}

export interface GetProductSkuRequest {
  id: string;
}

export interface ListSkuRequest {
  skuIds: string[];
}

export interface ListSkuResponse {
  skus: SkuResponse[];
}

export interface GetProductSkuResponse {
  id: string;
  name: string;
  description: string;
  brandId: string;
  categoryId: string;
  skus: SkuResponse[];
}

/** ======================= Update Product ======================= */
export interface UpdateProductRequest {
  id: string;
  name: string;
  description: string;
  brandId: string;
  categoryId: string;
  /** reuse input from Create */
  skus: CreateSkuInput[];
}

export interface UpdateProductResponse {
  product?: GetProductResponse | undefined;
}

/** ======================= Delete Product ======================= */
export interface DeleteProductRequest {
  id: string;
}

export interface DeleteProductResponse {
  message: boolean;
}

/** ======================= Get All Products ======================= */
export interface GetAllProductsRequest {
  page: number;
  limit: number;
  keyword: string;
  brandId: string;
  categoryId: string;
  sort: string;
}

export interface GetAllProductsResponse {
  products: GetProductResponse[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export interface SkuResponse {
  id: string;
  skuCode: string;
  price: number;
  stock: number;
  image: string;
  skuOptions: SkuOptionResponse[];
}

export interface SkuOptionResponse {
  attributeOptionId: string;
  attributeOptionValue: string;
  attribute?: AttributeDetail | undefined;
}

export interface AttributeDetail {
  id: string;
  name: string;
  description: string;
}

export interface SkuValidationInput {
  productId: string;
  skuId: string;
  skuCode: string;
  quantity: number;
}

export interface ValidateSkuInputRequest {
  items: SkuValidationInput[];
}

export interface SkuValidationResult {
  /** Thông tin sản phẩm */
  productId: string;
  name: string;
  description: string;
  brandId: string;
  categoryId: string;
  skuId: string;
  skuCode: string;
  price: number;
  stock: number;
  image: string;
  skuOptions: SkuOptionResponse[];
  /** Trạng thái kiểm tra */
  valid: boolean;
  inStock: boolean;
  availableStock: number;
  message: string;
}

export interface ValidateSkuInputResponse {
  allValid: boolean;
  results: SkuValidationResult[];
}

export const PRODUCT_PACKAGE_NAME = "product";

function createBaseCheckSkuAvailabilityRequest(): CheckSkuAvailabilityRequest {
  return { skuId: "", quantity: 0 };
}

export const CheckSkuAvailabilityRequest = {
  encode(message: CheckSkuAvailabilityRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skuId !== "") {
      writer.uint32(10).string(message.skuId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckSkuAvailabilityRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckSkuAvailabilityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuId = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCheckSkuAvailabilityResponse(): CheckSkuAvailabilityResponse {
  return {
    exists: false,
    inStock: false,
    availableStock: 0,
    message: "",
    productId: "",
    skuCode: "",
    price: 0,
    productName: "",
    description: "",
    image: "",
    brandId: "",
    categoryId: "",
    skuOptions: [],
  };
}

export const CheckSkuAvailabilityResponse = {
  encode(message: CheckSkuAvailabilityResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.exists !== false) {
      writer.uint32(8).bool(message.exists);
    }
    if (message.inStock !== false) {
      writer.uint32(16).bool(message.inStock);
    }
    if (message.availableStock !== 0) {
      writer.uint32(24).int32(message.availableStock);
    }
    if (message.message !== "") {
      writer.uint32(34).string(message.message);
    }
    if (message.productId !== "") {
      writer.uint32(42).string(message.productId);
    }
    if (message.skuCode !== "") {
      writer.uint32(50).string(message.skuCode);
    }
    if (message.price !== 0) {
      writer.uint32(57).double(message.price);
    }
    if (message.productName !== "") {
      writer.uint32(66).string(message.productName);
    }
    if (message.description !== "") {
      writer.uint32(74).string(message.description);
    }
    if (message.image !== "") {
      writer.uint32(82).string(message.image);
    }
    if (message.brandId !== "") {
      writer.uint32(90).string(message.brandId);
    }
    if (message.categoryId !== "") {
      writer.uint32(98).string(message.categoryId);
    }
    for (const v of message.skuOptions) {
      SkuOptionResponse.encode(v!, writer.uint32(106).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckSkuAvailabilityResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckSkuAvailabilityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.exists = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.inStock = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.availableStock = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.message = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.price = reader.double();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.productName = reader.string();
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.description = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.image = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.brandId = reader.string();
          continue;
        case 12:
          if (tag !== 98) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        case 13:
          if (tag !== 106) {
            break;
          }

          message.skuOptions.push(SkuOptionResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreateProductRequest(): CreateProductRequest {
  return { name: "", description: "", brandId: "", categoryId: "", skus: [] };
}

export const CreateProductRequest = {
  encode(message: CreateProductRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.brandId !== "") {
      writer.uint32(26).string(message.brandId);
    }
    if (message.categoryId !== "") {
      writer.uint32(34).string(message.categoryId);
    }
    for (const v of message.skus) {
      CreateSkuInput.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateProductRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.brandId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.skus.push(CreateSkuInput.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreateSkuInput(): CreateSkuInput {
  return { skuCode: "", price: 0, stock: 0, image: "", attributes: [] };
}

export const CreateSkuInput = {
  encode(message: CreateSkuInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.skuCode !== "") {
      writer.uint32(10).string(message.skuCode);
    }
    if (message.price !== 0) {
      writer.uint32(17).double(message.price);
    }
    if (message.stock !== 0) {
      writer.uint32(24).int32(message.stock);
    }
    if (message.image !== "") {
      writer.uint32(34).string(message.image);
    }
    for (const v of message.attributes) {
      AttributeInput.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateSkuInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSkuInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.price = reader.double();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.stock = reader.int32();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.image = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.attributes.push(AttributeInput.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAttributeInput(): AttributeInput {
  return { attributeOptionId: "" };
}

export const AttributeInput = {
  encode(message: AttributeInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.attributeOptionId !== "") {
      writer.uint32(10).string(message.attributeOptionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttributeInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeOptionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreateProductResponse(): CreateProductResponse {
  return {};
}

export const CreateProductResponse = {
  encode(message: CreateProductResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.product !== undefined) {
      GetProductResponse.encode(message.product, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateProductResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.product = GetProductResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetProductRequest(): GetProductRequest {
  return { id: "" };
}

export const GetProductRequest = {
  encode(message: GetProductRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.userId !== undefined) {
      writer.uint32(18).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProductRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetProductResponse(): GetProductResponse {
  return { id: "", name: "", description: "", brandId: "", categoryId: "", skus: [] };
}

export const GetProductResponse = {
  encode(message: GetProductResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.brandId !== "") {
      writer.uint32(34).string(message.brandId);
    }
    if (message.categoryId !== "") {
      writer.uint32(42).string(message.categoryId);
    }
    for (const v of message.skus) {
      SkuResponse.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProductResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.brandId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skus.push(SkuResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetProductSkuRequest(): GetProductSkuRequest {
  return { id: "" };
}

export const GetProductSkuRequest = {
  encode(message: GetProductSkuRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProductSkuRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductSkuRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseListSkuRequest(): ListSkuRequest {
  return { skuIds: [] };
}

export const ListSkuRequest = {
  encode(message: ListSkuRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.skuIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSkuRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSkuRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skuIds.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseListSkuResponse(): ListSkuResponse {
  return { skus: [] };
}

export const ListSkuResponse = {
  encode(message: ListSkuResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.skus) {
      SkuResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ListSkuResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSkuResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.skus.push(SkuResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetProductSkuResponse(): GetProductSkuResponse {
  return { id: "", name: "", description: "", brandId: "", categoryId: "", skus: [] };
}

export const GetProductSkuResponse = {
  encode(message: GetProductSkuResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.brandId !== "") {
      writer.uint32(34).string(message.brandId);
    }
    if (message.categoryId !== "") {
      writer.uint32(42).string(message.categoryId);
    }
    for (const v of message.skus) {
      SkuResponse.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetProductSkuResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetProductSkuResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.brandId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skus.push(SkuResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateProductRequest(): UpdateProductRequest {
  return { id: "", name: "", description: "", brandId: "", categoryId: "", skus: [] };
}

export const UpdateProductRequest = {
  encode(message: UpdateProductRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.brandId !== "") {
      writer.uint32(34).string(message.brandId);
    }
    if (message.categoryId !== "") {
      writer.uint32(42).string(message.categoryId);
    }
    for (const v of message.skus) {
      CreateSkuInput.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateProductRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.brandId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skus.push(CreateSkuInput.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateProductResponse(): UpdateProductResponse {
  return {};
}

export const UpdateProductResponse = {
  encode(message: UpdateProductResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.product !== undefined) {
      GetProductResponse.encode(message.product, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateProductResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.product = GetProductResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteProductRequest(): DeleteProductRequest {
  return { id: "" };
}

export const DeleteProductRequest = {
  encode(message: DeleteProductRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProductRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteProductResponse(): DeleteProductResponse {
  return { message: false };
}

export const DeleteProductResponse = {
  encode(message: DeleteProductResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.message !== false) {
      writer.uint32(8).bool(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteProductResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteProductResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.message = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAllProductsRequest(): GetAllProductsRequest {
  return { page: 0, limit: 0, keyword: "", brandId: "", categoryId: "", sort: "" };
}

export const GetAllProductsRequest = {
  encode(message: GetAllProductsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.keyword !== "") {
      writer.uint32(26).string(message.keyword);
    }
    if (message.brandId !== "") {
      writer.uint32(34).string(message.brandId);
    }
    if (message.categoryId !== "") {
      writer.uint32(42).string(message.categoryId);
    }
    if (message.sort !== "") {
      writer.uint32(50).string(message.sort);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllProductsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllProductsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.keyword = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.brandId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sort = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAllProductsResponse(): GetAllProductsResponse {
  return { products: [], total: 0, page: 0, limit: 0, totalPages: 0 };
}

export const GetAllProductsResponse = {
  encode(message: GetAllProductsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.products) {
      GetProductResponse.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    if (message.totalPages !== 0) {
      writer.uint32(40).int32(message.totalPages);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllProductsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllProductsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.products.push(GetProductResponse.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.totalPages = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseSkuResponse(): SkuResponse {
  return { id: "", skuCode: "", price: 0, stock: 0, image: "", skuOptions: [] };
}

export const SkuResponse = {
  encode(message: SkuResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.skuCode !== "") {
      writer.uint32(18).string(message.skuCode);
    }
    if (message.price !== 0) {
      writer.uint32(25).double(message.price);
    }
    if (message.stock !== 0) {
      writer.uint32(32).int32(message.stock);
    }
    if (message.image !== "") {
      writer.uint32(42).string(message.image);
    }
    for (const v of message.skuOptions) {
      SkuOptionResponse.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SkuResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.price = reader.double();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.stock = reader.int32();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.image = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skuOptions.push(SkuOptionResponse.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseSkuOptionResponse(): SkuOptionResponse {
  return { attributeOptionId: "", attributeOptionValue: "" };
}

export const SkuOptionResponse = {
  encode(message: SkuOptionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.attributeOptionId !== "") {
      writer.uint32(10).string(message.attributeOptionId);
    }
    if (message.attributeOptionValue !== "") {
      writer.uint32(18).string(message.attributeOptionValue);
    }
    if (message.attribute !== undefined) {
      AttributeDetail.encode(message.attribute, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SkuOptionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuOptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.attributeOptionId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributeOptionValue = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.attribute = AttributeDetail.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAttributeDetail(): AttributeDetail {
  return { id: "", name: "", description: "" };
}

export const AttributeDetail = {
  encode(message: AttributeDetail, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AttributeDetail {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttributeDetail();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseSkuValidationInput(): SkuValidationInput {
  return { productId: "", skuId: "", skuCode: "", quantity: 0 };
}

export const SkuValidationInput = {
  encode(message: SkuValidationInput, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.skuId !== "") {
      writer.uint32(18).string(message.skuId);
    }
    if (message.skuCode !== "") {
      writer.uint32(26).string(message.skuCode);
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int32(message.quantity);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SkuValidationInput {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuValidationInput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.skuId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.quantity = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseValidateSkuInputRequest(): ValidateSkuInputRequest {
  return { items: [] };
}

export const ValidateSkuInputRequest = {
  encode(message: ValidateSkuInputRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.items) {
      SkuValidationInput.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ValidateSkuInputRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateSkuInputRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(SkuValidationInput.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseSkuValidationResult(): SkuValidationResult {
  return {
    productId: "",
    name: "",
    description: "",
    brandId: "",
    categoryId: "",
    skuId: "",
    skuCode: "",
    price: 0,
    stock: 0,
    image: "",
    skuOptions: [],
    valid: false,
    inStock: false,
    availableStock: 0,
    message: "",
  };
}

export const SkuValidationResult = {
  encode(message: SkuValidationResult, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.productId !== "") {
      writer.uint32(10).string(message.productId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.brandId !== "") {
      writer.uint32(34).string(message.brandId);
    }
    if (message.categoryId !== "") {
      writer.uint32(42).string(message.categoryId);
    }
    if (message.skuId !== "") {
      writer.uint32(50).string(message.skuId);
    }
    if (message.skuCode !== "") {
      writer.uint32(58).string(message.skuCode);
    }
    if (message.price !== 0) {
      writer.uint32(65).double(message.price);
    }
    if (message.stock !== 0) {
      writer.uint32(72).int32(message.stock);
    }
    if (message.image !== "") {
      writer.uint32(82).string(message.image);
    }
    for (const v of message.skuOptions) {
      SkuOptionResponse.encode(v!, writer.uint32(90).fork()).ldelim();
    }
    if (message.valid !== false) {
      writer.uint32(96).bool(message.valid);
    }
    if (message.inStock !== false) {
      writer.uint32(104).bool(message.inStock);
    }
    if (message.availableStock !== 0) {
      writer.uint32(112).int32(message.availableStock);
    }
    if (message.message !== "") {
      writer.uint32(122).string(message.message);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SkuValidationResult {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSkuValidationResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.productId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.brandId = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.categoryId = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.skuId = reader.string();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.skuCode = reader.string();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.price = reader.double();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.stock = reader.int32();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.image = reader.string();
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.skuOptions.push(SkuOptionResponse.decode(reader, reader.uint32()));
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.valid = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.inStock = reader.bool();
          continue;
        case 14:
          if (tag !== 112) {
            break;
          }

          message.availableStock = reader.int32();
          continue;
        case 15:
          if (tag !== 122) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseValidateSkuInputResponse(): ValidateSkuInputResponse {
  return { allValid: false, results: [] };
}

export const ValidateSkuInputResponse = {
  encode(message: ValidateSkuInputResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.allValid !== false) {
      writer.uint32(8).bool(message.allValid);
    }
    for (const v of message.results) {
      SkuValidationResult.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ValidateSkuInputResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateSkuInputResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.allValid = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.results.push(SkuValidationResult.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

export interface ProductServiceClient {
  createProduct(request: CreateProductRequest, metadata: Metadata, ...rest: any): Observable<CreateProductResponse>;

  getProduct(request: GetProductRequest, metadata: Metadata, ...rest: any): Observable<GetProductResponse>;

  getProducts(request: GetAllProductsRequest, metadata: Metadata, ...rest: any): Observable<GetAllProductsResponse>;

  validateSkuInputs(
    request: ValidateSkuInputRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<ValidateSkuInputResponse>;

  updateProduct(request: UpdateProductRequest, metadata: Metadata, ...rest: any): Observable<UpdateProductResponse>;

  deleteProduct(request: DeleteProductRequest, metadata: Metadata, ...rest: any): Observable<DeleteProductResponse>;

  existingSku(
    request: CheckSkuAvailabilityRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<CheckSkuAvailabilityResponse>;
}

export interface ProductServiceController {
  createProduct(
    request: CreateProductRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CreateProductResponse> | Observable<CreateProductResponse> | CreateProductResponse;

  getProduct(
    request: GetProductRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetProductResponse> | Observable<GetProductResponse> | GetProductResponse;

  getProducts(
    request: GetAllProductsRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetAllProductsResponse> | Observable<GetAllProductsResponse> | GetAllProductsResponse;

  validateSkuInputs(
    request: ValidateSkuInputRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<ValidateSkuInputResponse> | Observable<ValidateSkuInputResponse> | ValidateSkuInputResponse;

  updateProduct(
    request: UpdateProductRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<UpdateProductResponse> | Observable<UpdateProductResponse> | UpdateProductResponse;

  deleteProduct(
    request: DeleteProductRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<DeleteProductResponse> | Observable<DeleteProductResponse> | DeleteProductResponse;

  existingSku(
    request: CheckSkuAvailabilityRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CheckSkuAvailabilityResponse> | Observable<CheckSkuAvailabilityResponse> | CheckSkuAvailabilityResponse;
}

export function ProductServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "createProduct",
      "getProduct",
      "getProducts",
      "validateSkuInputs",
      "updateProduct",
      "deleteProduct",
      "existingSku",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("ProductService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("ProductService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const PRODUCT_SERVICE_NAME = "ProductService";

export type ProductServiceService = typeof ProductServiceService;
export const ProductServiceService = {
  createProduct: {
    path: "/product.ProductService/CreateProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateProductRequest) => Buffer.from(CreateProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateProductRequest.decode(value),
    responseSerialize: (value: CreateProductResponse) => Buffer.from(CreateProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateProductResponse.decode(value),
  },
  getProduct: {
    path: "/product.ProductService/GetProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetProductRequest) => Buffer.from(GetProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetProductRequest.decode(value),
    responseSerialize: (value: GetProductResponse) => Buffer.from(GetProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetProductResponse.decode(value),
  },
  getProducts: {
    path: "/product.ProductService/GetProducts",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllProductsRequest) => Buffer.from(GetAllProductsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllProductsRequest.decode(value),
    responseSerialize: (value: GetAllProductsResponse) => Buffer.from(GetAllProductsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllProductsResponse.decode(value),
  },
  validateSkuInputs: {
    path: "/product.ProductService/ValidateSkuInputs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateSkuInputRequest) => Buffer.from(ValidateSkuInputRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ValidateSkuInputRequest.decode(value),
    responseSerialize: (value: ValidateSkuInputResponse) =>
      Buffer.from(ValidateSkuInputResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValidateSkuInputResponse.decode(value),
  },
  updateProduct: {
    path: "/product.ProductService/UpdateProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateProductRequest) => Buffer.from(UpdateProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateProductRequest.decode(value),
    responseSerialize: (value: UpdateProductResponse) => Buffer.from(UpdateProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UpdateProductResponse.decode(value),
  },
  deleteProduct: {
    path: "/product.ProductService/DeleteProduct",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteProductRequest) => Buffer.from(DeleteProductRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteProductRequest.decode(value),
    responseSerialize: (value: DeleteProductResponse) => Buffer.from(DeleteProductResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteProductResponse.decode(value),
  },
  existingSku: {
    path: "/product.ProductService/existingSku",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckSkuAvailabilityRequest) =>
      Buffer.from(CheckSkuAvailabilityRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CheckSkuAvailabilityRequest.decode(value),
    responseSerialize: (value: CheckSkuAvailabilityResponse) =>
      Buffer.from(CheckSkuAvailabilityResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckSkuAvailabilityResponse.decode(value),
  },
} as const;

export interface ProductServiceServer extends UntypedServiceImplementation {
  createProduct: handleUnaryCall<CreateProductRequest, CreateProductResponse>;
  getProduct: handleUnaryCall<GetProductRequest, GetProductResponse>;
  getProducts: handleUnaryCall<GetAllProductsRequest, GetAllProductsResponse>;
  validateSkuInputs: handleUnaryCall<ValidateSkuInputRequest, ValidateSkuInputResponse>;
  updateProduct: handleUnaryCall<UpdateProductRequest, UpdateProductResponse>;
  deleteProduct: handleUnaryCall<DeleteProductRequest, DeleteProductResponse>;
  existingSku: handleUnaryCall<CheckSkuAvailabilityRequest, CheckSkuAvailabilityResponse>;
}
