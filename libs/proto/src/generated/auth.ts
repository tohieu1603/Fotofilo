// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v6.31.1
// source: auth.proto

/* eslint-disable */
import { type handleUnaryCall, Metadata, type UntypedServiceImplementation } from "@grpc/grpc-js";
import { GrpcMethod, GrpcStreamMethod } from "@nestjs/microservices";
import * as _m0 from "protobufjs/minimal";
import { Observable } from "rxjs";

export const protobufPackage = "auth";

/** Authentication */
export interface RegisterRequest {
  name: string;
  email: string;
  phone: string;
  password: string;
}

export interface LoginRequest {
  email: string;
  password: string;
}

export interface RefreshTokenRequest {
  refreshToken: string;
}

export interface AuthResponse {
  accessToken: string;
  refreshToken: string;
  userId: string;
  email: string;
  roles: string[];
}

export interface ValidateTokenRequest {
  accessToken: string;
}

export interface ValidateTokenResponse {
  userId: string;
  email: string;
  isValid: boolean;
  roles: string[];
}

export interface LogoutRequest {
  refreshToken: string;
}

export interface LogoutResponse {
  success: boolean;
}

export interface User {
  id: string;
  name: string;
  email: string;
  phone: string;
  roles: string[];
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface UserResponse {
  user?: User | undefined;
}

export interface GetUserByIdRequest {
  id: string;
}

export interface CreateUserRequest {
  name: string;
  email: string;
  phone: string;
  password: string;
  rolesId: string[];
}

export interface UpdateUserRequest {
  id: string;
  name: string;
  phone: string;
  email: string;
  rolesId: string[];
  isActive: boolean;
}

export interface DeleteUserRequest {
  id: string;
}

export interface DeleteUserResponse {
  success: boolean;
}

export interface GetAllUserRequest {
  page: number;
  limit: number;
  search: string;
}

export interface GetAllUserResponse {
  users: User[];
  total: number;
  page: number;
  limit: number;
}

/** Authorization */
export interface CheckPermissionRequest {
  userId: string;
  resource: string;
  action: string;
}

export interface CheckPermissionResponse {
  hasPermission: boolean;
}

export interface Permission {
  id: string;
  name: string;
  resource: string;
  action: string;
  displayName: string;
  description: string;
  isActive: boolean;
}

export interface GetUserPermissionsRequest {
  userId: string;
}

export interface GetUserPermissionsResponse {
  permissions: Permission[];
}

export interface Role {
  id: string;
  name: string;
  displayName: string;
  description: string;
  isActive: boolean;
  isSystem: boolean;
}

export interface CheckRoleRequest {
  userId: string;
  roleNames: string[];
  requireAll: boolean;
}

export interface CheckRoleResponse {
  hasRole: boolean;
}

export interface GetUserRolesRequest {
  userId: string;
}

export interface GetUserRolesResponse {
  roles: Role[];
}

/** Role Management */
export interface AssignRoleToUserRequest {
  userId: string;
  roleId: string;
  assignedBy: string;
  expiresAt: string;
}

export interface AssignRoleToUserResponse {
  userRoleId: string;
}

export interface RemoveRoleFromUserRequest {
  userId: string;
  roleId: string;
}

export interface RemoveRoleFromUserResponse {
  success: boolean;
}

export interface AssignPermissionToRoleRequest {
  roleId: string;
  permissionId: string;
}

export interface AssignPermissionToRoleResponse {
  rolePermissionId: string;
}

export interface RemovePermissionFromRoleRequest {
  roleId: string;
  permissionId: string;
}

export interface RemovePermissionFromRoleResponse {
  success: boolean;
}

export interface CreateRoleRequest {
  name: string;
  displayName: string;
  description: string;
  isActive: boolean;
  isSystem: boolean;
}

export interface RoleResponse {
  role?: Role | undefined;
}

export interface UpdateRoleRequest {
  id: string;
  name: string;
  displayName: string;
  description: string;
  isActive: boolean;
}

export interface DeleteRoleRequest {
  id: string;
}

export interface DeleteRoleResponse {
  success: boolean;
}

export interface GetAllRolesRequest {
}

export interface GetAllRolesResponse {
  roles: Role[];
}

/** Permission Management */
export interface CreatePermissionRequest {
  name: string;
  resource: string;
  action: string;
  displayName: string;
  description: string;
  isActive: boolean;
}

export interface PermissionResponse {
  permission?: Permission | undefined;
}

export interface UpdatePermissionRequest {
  id: string;
  name: string;
  resource: string;
  action: string;
  displayName: string;
  description: string;
  isActive: boolean;
}

export interface DeletePermissionRequest {
  id: string;
}

export interface DeletePermissionResponse {
  success: boolean;
}

export interface GetAllPermissionsRequest {
}

export interface GetAllPermissionsResponse {
  permissions: Permission[];
}

export const AUTH_PACKAGE_NAME = "auth";

function createBaseRegisterRequest(): RegisterRequest {
  return { name: "", email: "", phone: "", password: "" };
}

export const RegisterRequest = {
  encode(message: RegisterRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.phone !== "") {
      writer.uint32(26).string(message.phone);
    }
    if (message.password !== "") {
      writer.uint32(34).string(message.password);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RegisterRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.phone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseLoginRequest(): LoginRequest {
  return { email: "", password: "" };
}

export const LoginRequest = {
  encode(message: LoginRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.email !== "") {
      writer.uint32(10).string(message.email);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.email = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseRefreshTokenRequest(): RefreshTokenRequest {
  return { refreshToken: "" };
}

export const RefreshTokenRequest = {
  encode(message: RefreshTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RefreshTokenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRefreshTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAuthResponse(): AuthResponse {
  return { accessToken: "", refreshToken: "", userId: "", email: "", roles: [] };
}

export const AuthResponse = {
  encode(message: AuthResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    if (message.refreshToken !== "") {
      writer.uint32(18).string(message.refreshToken);
    }
    if (message.userId !== "") {
      writer.uint32(26).string(message.userId);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    for (const v of message.roles) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AuthResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.roles.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseValidateTokenRequest(): ValidateTokenRequest {
  return { accessToken: "" };
}

export const ValidateTokenRequest = {
  encode(message: ValidateTokenRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.accessToken !== "") {
      writer.uint32(10).string(message.accessToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ValidateTokenRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.accessToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseValidateTokenResponse(): ValidateTokenResponse {
  return { userId: "", email: "", isValid: false, roles: [] };
}

export const ValidateTokenResponse = {
  encode(message: ValidateTokenResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.isValid !== false) {
      writer.uint32(24).bool(message.isValid);
    }
    for (const v of message.roles) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): ValidateTokenResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidateTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isValid = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.roles.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseLogoutRequest(): LogoutRequest {
  return { refreshToken: "" };
}

export const LogoutRequest = {
  encode(message: LogoutRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.refreshToken !== "") {
      writer.uint32(10).string(message.refreshToken);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogoutRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.refreshToken = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseLogoutResponse(): LogoutResponse {
  return { success: false };
}

export const LogoutResponse = {
  encode(message: LogoutResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): LogoutResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogoutResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUser(): User {
  return { id: "", name: "", email: "", phone: "", roles: [], isActive: false, createdAt: "", updatedAt: "" };
}

export const User = {
  encode(message: User, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.phone !== "") {
      writer.uint32(34).string(message.phone);
    }
    for (const v of message.roles) {
      writer.uint32(42).string(v!);
    }
    if (message.isActive !== false) {
      writer.uint32(48).bool(message.isActive);
    }
    if (message.createdAt !== "") {
      writer.uint32(58).string(message.createdAt);
    }
    if (message.updatedAt !== "") {
      writer.uint32(66).string(message.updatedAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): User {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUser();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.phone = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.roles.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.updatedAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUserResponse(): UserResponse {
  return {};
}

export const UserResponse = {
  encode(message: UserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.user = User.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetUserByIdRequest(): GetUserByIdRequest {
  return { id: "" };
}

export const GetUserByIdRequest = {
  encode(message: GetUserByIdRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserByIdRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserByIdRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreateUserRequest(): CreateUserRequest {
  return { name: "", email: "", phone: "", password: "", rolesId: [] };
}

export const CreateUserRequest = {
  encode(message: CreateUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.email !== "") {
      writer.uint32(18).string(message.email);
    }
    if (message.phone !== "") {
      writer.uint32(26).string(message.phone);
    }
    if (message.password !== "") {
      writer.uint32(34).string(message.password);
    }
    for (const v of message.rolesId) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.email = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.phone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.password = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rolesId.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateUserRequest(): UpdateUserRequest {
  return { id: "", name: "", phone: "", email: "", rolesId: [], isActive: false };
}

export const UpdateUserRequest = {
  encode(message: UpdateUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.phone !== "") {
      writer.uint32(26).string(message.phone);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    for (const v of message.rolesId) {
      writer.uint32(42).string(v!);
    }
    if (message.isActive !== false) {
      writer.uint32(48).bool(message.isActive);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.phone = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.rolesId.push(reader.string());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isActive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteUserRequest(): DeleteUserRequest {
  return { id: "" };
}

export const DeleteUserRequest = {
  encode(message: DeleteUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteUserResponse(): DeleteUserResponse {
  return { success: false };
}

export const DeleteUserResponse = {
  encode(message: DeleteUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAllUserRequest(): GetAllUserRequest {
  return { page: 0, limit: 0, search: "" };
}

export const GetAllUserRequest = {
  encode(message: GetAllUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.page !== 0) {
      writer.uint32(8).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(16).int32(message.limit);
    }
    if (message.search !== "") {
      writer.uint32(26).string(message.search);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.limit = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.search = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAllUserResponse(): GetAllUserResponse {
  return { users: [], total: 0, page: 0, limit: 0 };
}

export const GetAllUserResponse = {
  encode(message: GetAllUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    if (message.total !== 0) {
      writer.uint32(16).int32(message.total);
    }
    if (message.page !== 0) {
      writer.uint32(24).int32(message.page);
    }
    if (message.limit !== 0) {
      writer.uint32(32).int32(message.limit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.users.push(User.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.total = reader.int32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.page = reader.int32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.limit = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCheckPermissionRequest(): CheckPermissionRequest {
  return { userId: "", resource: "", action: "" };
}

export const CheckPermissionRequest = {
  encode(message: CheckPermissionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.resource !== "") {
      writer.uint32(18).string(message.resource);
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckPermissionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckPermissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCheckPermissionResponse(): CheckPermissionResponse {
  return { hasPermission: false };
}

export const CheckPermissionResponse = {
  encode(message: CheckPermissionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hasPermission !== false) {
      writer.uint32(8).bool(message.hasPermission);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckPermissionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckPermissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hasPermission = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBasePermission(): Permission {
  return { id: "", name: "", resource: "", action: "", displayName: "", description: "", isActive: false };
}

export const Permission = {
  encode(message: Permission, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.resource !== "") {
      writer.uint32(26).string(message.resource);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Permission {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetUserPermissionsRequest(): GetUserPermissionsRequest {
  return { userId: "" };
}

export const GetUserPermissionsRequest = {
  encode(message: GetUserPermissionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserPermissionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserPermissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetUserPermissionsResponse(): GetUserPermissionsResponse {
  return { permissions: [] };
}

export const GetUserPermissionsResponse = {
  encode(message: GetUserPermissionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.permissions) {
      Permission.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserPermissionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserPermissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.permissions.push(Permission.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseRole(): Role {
  return { id: "", name: "", displayName: "", description: "", isActive: false, isSystem: false };
}

export const Role = {
  encode(message: Role, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.isActive !== false) {
      writer.uint32(40).bool(message.isActive);
    }
    if (message.isSystem !== false) {
      writer.uint32(48).bool(message.isSystem);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Role {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRole();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isSystem = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCheckRoleRequest(): CheckRoleRequest {
  return { userId: "", roleNames: [], requireAll: false };
}

export const CheckRoleRequest = {
  encode(message: CheckRoleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    for (const v of message.roleNames) {
      writer.uint32(18).string(v!);
    }
    if (message.requireAll !== false) {
      writer.uint32(24).bool(message.requireAll);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckRoleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.roleNames.push(reader.string());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.requireAll = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCheckRoleResponse(): CheckRoleResponse {
  return { hasRole: false };
}

export const CheckRoleResponse = {
  encode(message: CheckRoleResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.hasRole !== false) {
      writer.uint32(8).bool(message.hasRole);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CheckRoleResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCheckRoleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.hasRole = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetUserRolesRequest(): GetUserRolesRequest {
  return { userId: "" };
}

export const GetUserRolesRequest = {
  encode(message: GetUserRolesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserRolesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRolesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetUserRolesResponse(): GetUserRolesResponse {
  return { roles: [] };
}

export const GetUserRolesResponse = {
  encode(message: GetUserRolesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.roles) {
      Role.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetUserRolesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetUserRolesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.roles.push(Role.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAssignRoleToUserRequest(): AssignRoleToUserRequest {
  return { userId: "", roleId: "", assignedBy: "", expiresAt: "" };
}

export const AssignRoleToUserRequest = {
  encode(message: AssignRoleToUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.roleId !== "") {
      writer.uint32(18).string(message.roleId);
    }
    if (message.assignedBy !== "") {
      writer.uint32(26).string(message.assignedBy);
    }
    if (message.expiresAt !== "") {
      writer.uint32(34).string(message.expiresAt);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssignRoleToUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignRoleToUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.roleId = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.assignedBy = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.expiresAt = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAssignRoleToUserResponse(): AssignRoleToUserResponse {
  return { userRoleId: "" };
}

export const AssignRoleToUserResponse = {
  encode(message: AssignRoleToUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userRoleId !== "") {
      writer.uint32(10).string(message.userRoleId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssignRoleToUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignRoleToUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userRoleId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseRemoveRoleFromUserRequest(): RemoveRoleFromUserRequest {
  return { userId: "", roleId: "" };
}

export const RemoveRoleFromUserRequest = {
  encode(message: RemoveRoleFromUserRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.roleId !== "") {
      writer.uint32(18).string(message.roleId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveRoleFromUserRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveRoleFromUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.roleId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseRemoveRoleFromUserResponse(): RemoveRoleFromUserResponse {
  return { success: false };
}

export const RemoveRoleFromUserResponse = {
  encode(message: RemoveRoleFromUserResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemoveRoleFromUserResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveRoleFromUserResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAssignPermissionToRoleRequest(): AssignPermissionToRoleRequest {
  return { roleId: "", permissionId: "" };
}

export const AssignPermissionToRoleRequest = {
  encode(message: AssignPermissionToRoleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.roleId !== "") {
      writer.uint32(10).string(message.roleId);
    }
    if (message.permissionId !== "") {
      writer.uint32(18).string(message.permissionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssignPermissionToRoleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignPermissionToRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.roleId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.permissionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseAssignPermissionToRoleResponse(): AssignPermissionToRoleResponse {
  return { rolePermissionId: "" };
}

export const AssignPermissionToRoleResponse = {
  encode(message: AssignPermissionToRoleResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.rolePermissionId !== "") {
      writer.uint32(10).string(message.rolePermissionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssignPermissionToRoleResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignPermissionToRoleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.rolePermissionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseRemovePermissionFromRoleRequest(): RemovePermissionFromRoleRequest {
  return { roleId: "", permissionId: "" };
}

export const RemovePermissionFromRoleRequest = {
  encode(message: RemovePermissionFromRoleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.roleId !== "") {
      writer.uint32(10).string(message.roleId);
    }
    if (message.permissionId !== "") {
      writer.uint32(18).string(message.permissionId);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemovePermissionFromRoleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemovePermissionFromRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.roleId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.permissionId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseRemovePermissionFromRoleResponse(): RemovePermissionFromRoleResponse {
  return { success: false };
}

export const RemovePermissionFromRoleResponse = {
  encode(message: RemovePermissionFromRoleResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RemovePermissionFromRoleResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemovePermissionFromRoleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreateRoleRequest(): CreateRoleRequest {
  return { name: "", displayName: "", description: "", isActive: false, isSystem: false };
}

export const CreateRoleRequest = {
  encode(message: CreateRoleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.isActive !== false) {
      writer.uint32(32).bool(message.isActive);
    }
    if (message.isSystem !== false) {
      writer.uint32(40).bool(message.isSystem);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreateRoleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isSystem = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseRoleResponse(): RoleResponse {
  return {};
}

export const RoleResponse = {
  encode(message: RoleResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.role !== undefined) {
      Role.encode(message.role, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): RoleResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.role = Role.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUpdateRoleRequest(): UpdateRoleRequest {
  return { id: "", name: "", displayName: "", description: "", isActive: false };
}

export const UpdateRoleRequest = {
  encode(message: UpdateRoleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.isActive !== false) {
      writer.uint32(40).bool(message.isActive);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdateRoleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.isActive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteRoleRequest(): DeleteRoleRequest {
  return { id: "" };
}

export const DeleteRoleRequest = {
  encode(message: DeleteRoleRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteRoleRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeleteRoleResponse(): DeleteRoleResponse {
  return { success: false };
}

export const DeleteRoleResponse = {
  encode(message: DeleteRoleResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeleteRoleResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAllRolesRequest(): GetAllRolesRequest {
  return {};
}

export const GetAllRolesRequest = {
  encode(_: GetAllRolesRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllRolesRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllRolesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAllRolesResponse(): GetAllRolesResponse {
  return { roles: [] };
}

export const GetAllRolesResponse = {
  encode(message: GetAllRolesResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.roles) {
      Role.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllRolesResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllRolesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.roles.push(Role.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseCreatePermissionRequest(): CreatePermissionRequest {
  return { name: "", resource: "", action: "", displayName: "", description: "", isActive: false };
}

export const CreatePermissionRequest = {
  encode(message: CreatePermissionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.resource !== "") {
      writer.uint32(18).string(message.resource);
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.isActive !== false) {
      writer.uint32(48).bool(message.isActive);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): CreatePermissionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreatePermissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.isActive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBasePermissionResponse(): PermissionResponse {
  return {};
}

export const PermissionResponse = {
  encode(message: PermissionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.permission !== undefined) {
      Permission.encode(message.permission, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): PermissionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePermissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.permission = Permission.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseUpdatePermissionRequest(): UpdatePermissionRequest {
  return { id: "", name: "", resource: "", action: "", displayName: "", description: "", isActive: false };
}

export const UpdatePermissionRequest = {
  encode(message: UpdatePermissionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.resource !== "") {
      writer.uint32(26).string(message.resource);
    }
    if (message.action !== "") {
      writer.uint32(34).string(message.action);
    }
    if (message.displayName !== "") {
      writer.uint32(42).string(message.displayName);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (message.isActive !== false) {
      writer.uint32(56).bool(message.isActive);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): UpdatePermissionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdatePermissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.resource = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.action = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.displayName = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.isActive = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeletePermissionRequest(): DeletePermissionRequest {
  return { id: "" };
}

export const DeletePermissionRequest = {
  encode(message: DeletePermissionRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeletePermissionRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePermissionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseDeletePermissionResponse(): DeletePermissionResponse {
  return { success: false };
}

export const DeletePermissionResponse = {
  encode(message: DeletePermissionResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): DeletePermissionResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeletePermissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAllPermissionsRequest(): GetAllPermissionsRequest {
  return {};
}

export const GetAllPermissionsRequest = {
  encode(_: GetAllPermissionsRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllPermissionsRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllPermissionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

function createBaseGetAllPermissionsResponse(): GetAllPermissionsResponse {
  return { permissions: [] };
}

export const GetAllPermissionsResponse = {
  encode(message: GetAllPermissionsResponse, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.permissions) {
      Permission.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): GetAllPermissionsResponse {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetAllPermissionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.permissions.push(Permission.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },
};

export interface AuthServiceClient {
  register(request: RegisterRequest, metadata: Metadata, ...rest: any): Observable<AuthResponse>;

  login(request: LoginRequest, metadata: Metadata, ...rest: any): Observable<AuthResponse>;

  refreshToken(request: RefreshTokenRequest, metadata: Metadata, ...rest: any): Observable<AuthResponse>;

  validateToken(request: ValidateTokenRequest, metadata: Metadata, ...rest: any): Observable<ValidateTokenResponse>;

  logout(request: LogoutRequest, metadata: Metadata, ...rest: any): Observable<LogoutResponse>;

  checkPermission(
    request: CheckPermissionRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<CheckPermissionResponse>;

  getUserPermissions(
    request: GetUserPermissionsRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<GetUserPermissionsResponse>;

  checkRole(request: CheckRoleRequest, metadata: Metadata, ...rest: any): Observable<CheckRoleResponse>;

  getUserRoles(request: GetUserRolesRequest, metadata: Metadata, ...rest: any): Observable<GetUserRolesResponse>;

  getAllUsers(request: GetAllUserRequest, metadata: Metadata, ...rest: any): Observable<GetAllUserResponse>;

  getUserById(request: GetUserByIdRequest, metadata: Metadata, ...rest: any): Observable<UserResponse>;

  createUser(request: CreateUserRequest, metadata: Metadata, ...rest: any): Observable<UserResponse>;

  updateUser(request: UpdateUserRequest, metadata: Metadata, ...rest: any): Observable<UserResponse>;

  deleteUser(request: DeleteUserRequest, metadata: Metadata, ...rest: any): Observable<DeleteUserResponse>;

  assignRoleToUser(
    request: AssignRoleToUserRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<AssignRoleToUserResponse>;

  removeRoleFromUser(
    request: RemoveRoleFromUserRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<RemoveRoleFromUserResponse>;

  assignPermissionToRole(
    request: AssignPermissionToRoleRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<AssignPermissionToRoleResponse>;

  removePermissionFromRole(
    request: RemovePermissionFromRoleRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<RemovePermissionFromRoleResponse>;

  createRole(request: CreateRoleRequest, metadata: Metadata, ...rest: any): Observable<RoleResponse>;

  updateRole(request: UpdateRoleRequest, metadata: Metadata, ...rest: any): Observable<RoleResponse>;

  deleteRole(request: DeleteRoleRequest, metadata: Metadata, ...rest: any): Observable<DeleteRoleResponse>;

  getAllRoles(request: GetAllRolesRequest, metadata: Metadata, ...rest: any): Observable<GetAllRolesResponse>;

  createPermission(request: CreatePermissionRequest, metadata: Metadata, ...rest: any): Observable<PermissionResponse>;

  updatePermission(request: UpdatePermissionRequest, metadata: Metadata, ...rest: any): Observable<PermissionResponse>;

  deletePermission(
    request: DeletePermissionRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<DeletePermissionResponse>;

  getAllPermissions(
    request: GetAllPermissionsRequest,
    metadata: Metadata,
    ...rest: any
  ): Observable<GetAllPermissionsResponse>;
}

export interface AuthServiceController {
  register(
    request: RegisterRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<AuthResponse> | Observable<AuthResponse> | AuthResponse;

  login(
    request: LoginRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<AuthResponse> | Observable<AuthResponse> | AuthResponse;

  refreshToken(
    request: RefreshTokenRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<AuthResponse> | Observable<AuthResponse> | AuthResponse;

  validateToken(
    request: ValidateTokenRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<ValidateTokenResponse> | Observable<ValidateTokenResponse> | ValidateTokenResponse;

  logout(
    request: LogoutRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<LogoutResponse> | Observable<LogoutResponse> | LogoutResponse;

  checkPermission(
    request: CheckPermissionRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CheckPermissionResponse> | Observable<CheckPermissionResponse> | CheckPermissionResponse;

  getUserPermissions(
    request: GetUserPermissionsRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetUserPermissionsResponse> | Observable<GetUserPermissionsResponse> | GetUserPermissionsResponse;

  checkRole(
    request: CheckRoleRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<CheckRoleResponse> | Observable<CheckRoleResponse> | CheckRoleResponse;

  getUserRoles(
    request: GetUserRolesRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetUserRolesResponse> | Observable<GetUserRolesResponse> | GetUserRolesResponse;

  getAllUsers(
    request: GetAllUserRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetAllUserResponse> | Observable<GetAllUserResponse> | GetAllUserResponse;

  getUserById(
    request: GetUserByIdRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<UserResponse> | Observable<UserResponse> | UserResponse;

  createUser(
    request: CreateUserRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<UserResponse> | Observable<UserResponse> | UserResponse;

  updateUser(
    request: UpdateUserRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<UserResponse> | Observable<UserResponse> | UserResponse;

  deleteUser(
    request: DeleteUserRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<DeleteUserResponse> | Observable<DeleteUserResponse> | DeleteUserResponse;

  assignRoleToUser(
    request: AssignRoleToUserRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<AssignRoleToUserResponse> | Observable<AssignRoleToUserResponse> | AssignRoleToUserResponse;

  removeRoleFromUser(
    request: RemoveRoleFromUserRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<RemoveRoleFromUserResponse> | Observable<RemoveRoleFromUserResponse> | RemoveRoleFromUserResponse;

  assignPermissionToRole(
    request: AssignPermissionToRoleRequest,
    metadata: Metadata,
    ...rest: any
  ):
    | Promise<AssignPermissionToRoleResponse>
    | Observable<AssignPermissionToRoleResponse>
    | AssignPermissionToRoleResponse;

  removePermissionFromRole(
    request: RemovePermissionFromRoleRequest,
    metadata: Metadata,
    ...rest: any
  ):
    | Promise<RemovePermissionFromRoleResponse>
    | Observable<RemovePermissionFromRoleResponse>
    | RemovePermissionFromRoleResponse;

  createRole(
    request: CreateRoleRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<RoleResponse> | Observable<RoleResponse> | RoleResponse;

  updateRole(
    request: UpdateRoleRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<RoleResponse> | Observable<RoleResponse> | RoleResponse;

  deleteRole(
    request: DeleteRoleRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<DeleteRoleResponse> | Observable<DeleteRoleResponse> | DeleteRoleResponse;

  getAllRoles(
    request: GetAllRolesRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetAllRolesResponse> | Observable<GetAllRolesResponse> | GetAllRolesResponse;

  createPermission(
    request: CreatePermissionRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<PermissionResponse> | Observable<PermissionResponse> | PermissionResponse;

  updatePermission(
    request: UpdatePermissionRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<PermissionResponse> | Observable<PermissionResponse> | PermissionResponse;

  deletePermission(
    request: DeletePermissionRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<DeletePermissionResponse> | Observable<DeletePermissionResponse> | DeletePermissionResponse;

  getAllPermissions(
    request: GetAllPermissionsRequest,
    metadata: Metadata,
    ...rest: any
  ): Promise<GetAllPermissionsResponse> | Observable<GetAllPermissionsResponse> | GetAllPermissionsResponse;
}

export function AuthServiceControllerMethods() {
  return function (constructor: Function) {
    const grpcMethods: string[] = [
      "register",
      "login",
      "refreshToken",
      "validateToken",
      "logout",
      "checkPermission",
      "getUserPermissions",
      "checkRole",
      "getUserRoles",
      "getAllUsers",
      "getUserById",
      "createUser",
      "updateUser",
      "deleteUser",
      "assignRoleToUser",
      "removeRoleFromUser",
      "assignPermissionToRole",
      "removePermissionFromRole",
      "createRole",
      "updateRole",
      "deleteRole",
      "getAllRoles",
      "createPermission",
      "updatePermission",
      "deletePermission",
      "getAllPermissions",
    ];
    for (const method of grpcMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcMethod("AuthService", method)(constructor.prototype[method], method, descriptor);
    }
    const grpcStreamMethods: string[] = [];
    for (const method of grpcStreamMethods) {
      const descriptor: any = Reflect.getOwnPropertyDescriptor(constructor.prototype, method);
      GrpcStreamMethod("AuthService", method)(constructor.prototype[method], method, descriptor);
    }
  };
}

export const AUTH_SERVICE_NAME = "AuthService";

export type AuthServiceService = typeof AuthServiceService;
export const AuthServiceService = {
  register: {
    path: "/auth.AuthService/Register",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RegisterRequest) => Buffer.from(RegisterRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RegisterRequest.decode(value),
    responseSerialize: (value: AuthResponse) => Buffer.from(AuthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuthResponse.decode(value),
  },
  login: {
    path: "/auth.AuthService/Login",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LoginRequest) => Buffer.from(LoginRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LoginRequest.decode(value),
    responseSerialize: (value: AuthResponse) => Buffer.from(AuthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuthResponse.decode(value),
  },
  refreshToken: {
    path: "/auth.AuthService/RefreshToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RefreshTokenRequest) => Buffer.from(RefreshTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RefreshTokenRequest.decode(value),
    responseSerialize: (value: AuthResponse) => Buffer.from(AuthResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AuthResponse.decode(value),
  },
  validateToken: {
    path: "/auth.AuthService/ValidateToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ValidateTokenRequest) => Buffer.from(ValidateTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ValidateTokenRequest.decode(value),
    responseSerialize: (value: ValidateTokenResponse) => Buffer.from(ValidateTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ValidateTokenResponse.decode(value),
  },
  logout: {
    path: "/auth.AuthService/Logout",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: LogoutRequest) => Buffer.from(LogoutRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LogoutRequest.decode(value),
    responseSerialize: (value: LogoutResponse) => Buffer.from(LogoutResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => LogoutResponse.decode(value),
  },
  checkPermission: {
    path: "/auth.AuthService/CheckPermission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckPermissionRequest) => Buffer.from(CheckPermissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CheckPermissionRequest.decode(value),
    responseSerialize: (value: CheckPermissionResponse) => Buffer.from(CheckPermissionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckPermissionResponse.decode(value),
  },
  getUserPermissions: {
    path: "/auth.AuthService/GetUserPermissions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserPermissionsRequest) =>
      Buffer.from(GetUserPermissionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUserPermissionsRequest.decode(value),
    responseSerialize: (value: GetUserPermissionsResponse) =>
      Buffer.from(GetUserPermissionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUserPermissionsResponse.decode(value),
  },
  checkRole: {
    path: "/auth.AuthService/CheckRole",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CheckRoleRequest) => Buffer.from(CheckRoleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CheckRoleRequest.decode(value),
    responseSerialize: (value: CheckRoleResponse) => Buffer.from(CheckRoleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CheckRoleResponse.decode(value),
  },
  getUserRoles: {
    path: "/auth.AuthService/GetUserRoles",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserRolesRequest) => Buffer.from(GetUserRolesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUserRolesRequest.decode(value),
    responseSerialize: (value: GetUserRolesResponse) => Buffer.from(GetUserRolesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetUserRolesResponse.decode(value),
  },
  getAllUsers: {
    path: "/auth.AuthService/GetAllUsers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllUserRequest) => Buffer.from(GetAllUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllUserRequest.decode(value),
    responseSerialize: (value: GetAllUserResponse) => Buffer.from(GetAllUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllUserResponse.decode(value),
  },
  getUserById: {
    path: "/auth.AuthService/GetUserById",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetUserByIdRequest) => Buffer.from(GetUserByIdRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetUserByIdRequest.decode(value),
    responseSerialize: (value: UserResponse) => Buffer.from(UserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UserResponse.decode(value),
  },
  createUser: {
    path: "/auth.AuthService/CreateUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateUserRequest) => Buffer.from(CreateUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateUserRequest.decode(value),
    responseSerialize: (value: UserResponse) => Buffer.from(UserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UserResponse.decode(value),
  },
  updateUser: {
    path: "/auth.AuthService/UpdateUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateUserRequest) => Buffer.from(UpdateUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateUserRequest.decode(value),
    responseSerialize: (value: UserResponse) => Buffer.from(UserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UserResponse.decode(value),
  },
  deleteUser: {
    path: "/auth.AuthService/DeleteUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteUserRequest) => Buffer.from(DeleteUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteUserRequest.decode(value),
    responseSerialize: (value: DeleteUserResponse) => Buffer.from(DeleteUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteUserResponse.decode(value),
  },
  assignRoleToUser: {
    path: "/auth.AuthService/AssignRoleToUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AssignRoleToUserRequest) => Buffer.from(AssignRoleToUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AssignRoleToUserRequest.decode(value),
    responseSerialize: (value: AssignRoleToUserResponse) =>
      Buffer.from(AssignRoleToUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssignRoleToUserResponse.decode(value),
  },
  removeRoleFromUser: {
    path: "/auth.AuthService/RemoveRoleFromUser",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemoveRoleFromUserRequest) =>
      Buffer.from(RemoveRoleFromUserRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RemoveRoleFromUserRequest.decode(value),
    responseSerialize: (value: RemoveRoleFromUserResponse) =>
      Buffer.from(RemoveRoleFromUserResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RemoveRoleFromUserResponse.decode(value),
  },
  assignPermissionToRole: {
    path: "/auth.AuthService/AssignPermissionToRole",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: AssignPermissionToRoleRequest) =>
      Buffer.from(AssignPermissionToRoleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => AssignPermissionToRoleRequest.decode(value),
    responseSerialize: (value: AssignPermissionToRoleResponse) =>
      Buffer.from(AssignPermissionToRoleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => AssignPermissionToRoleResponse.decode(value),
  },
  removePermissionFromRole: {
    path: "/auth.AuthService/RemovePermissionFromRole",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RemovePermissionFromRoleRequest) =>
      Buffer.from(RemovePermissionFromRoleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RemovePermissionFromRoleRequest.decode(value),
    responseSerialize: (value: RemovePermissionFromRoleResponse) =>
      Buffer.from(RemovePermissionFromRoleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RemovePermissionFromRoleResponse.decode(value),
  },
  createRole: {
    path: "/auth.AuthService/CreateRole",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateRoleRequest) => Buffer.from(CreateRoleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateRoleRequest.decode(value),
    responseSerialize: (value: RoleResponse) => Buffer.from(RoleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RoleResponse.decode(value),
  },
  updateRole: {
    path: "/auth.AuthService/UpdateRole",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdateRoleRequest) => Buffer.from(UpdateRoleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdateRoleRequest.decode(value),
    responseSerialize: (value: RoleResponse) => Buffer.from(RoleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RoleResponse.decode(value),
  },
  deleteRole: {
    path: "/auth.AuthService/DeleteRole",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeleteRoleRequest) => Buffer.from(DeleteRoleRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeleteRoleRequest.decode(value),
    responseSerialize: (value: DeleteRoleResponse) => Buffer.from(DeleteRoleResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeleteRoleResponse.decode(value),
  },
  getAllRoles: {
    path: "/auth.AuthService/GetAllRoles",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllRolesRequest) => Buffer.from(GetAllRolesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllRolesRequest.decode(value),
    responseSerialize: (value: GetAllRolesResponse) => Buffer.from(GetAllRolesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllRolesResponse.decode(value),
  },
  createPermission: {
    path: "/auth.AuthService/CreatePermission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreatePermissionRequest) => Buffer.from(CreatePermissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreatePermissionRequest.decode(value),
    responseSerialize: (value: PermissionResponse) => Buffer.from(PermissionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PermissionResponse.decode(value),
  },
  updatePermission: {
    path: "/auth.AuthService/UpdatePermission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UpdatePermissionRequest) => Buffer.from(UpdatePermissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UpdatePermissionRequest.decode(value),
    responseSerialize: (value: PermissionResponse) => Buffer.from(PermissionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => PermissionResponse.decode(value),
  },
  deletePermission: {
    path: "/auth.AuthService/DeletePermission",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DeletePermissionRequest) => Buffer.from(DeletePermissionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DeletePermissionRequest.decode(value),
    responseSerialize: (value: DeletePermissionResponse) =>
      Buffer.from(DeletePermissionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DeletePermissionResponse.decode(value),
  },
  getAllPermissions: {
    path: "/auth.AuthService/GetAllPermissions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetAllPermissionsRequest) => Buffer.from(GetAllPermissionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetAllPermissionsRequest.decode(value),
    responseSerialize: (value: GetAllPermissionsResponse) =>
      Buffer.from(GetAllPermissionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetAllPermissionsResponse.decode(value),
  },
} as const;

export interface AuthServiceServer extends UntypedServiceImplementation {
  register: handleUnaryCall<RegisterRequest, AuthResponse>;
  login: handleUnaryCall<LoginRequest, AuthResponse>;
  refreshToken: handleUnaryCall<RefreshTokenRequest, AuthResponse>;
  validateToken: handleUnaryCall<ValidateTokenRequest, ValidateTokenResponse>;
  logout: handleUnaryCall<LogoutRequest, LogoutResponse>;
  checkPermission: handleUnaryCall<CheckPermissionRequest, CheckPermissionResponse>;
  getUserPermissions: handleUnaryCall<GetUserPermissionsRequest, GetUserPermissionsResponse>;
  checkRole: handleUnaryCall<CheckRoleRequest, CheckRoleResponse>;
  getUserRoles: handleUnaryCall<GetUserRolesRequest, GetUserRolesResponse>;
  getAllUsers: handleUnaryCall<GetAllUserRequest, GetAllUserResponse>;
  getUserById: handleUnaryCall<GetUserByIdRequest, UserResponse>;
  createUser: handleUnaryCall<CreateUserRequest, UserResponse>;
  updateUser: handleUnaryCall<UpdateUserRequest, UserResponse>;
  deleteUser: handleUnaryCall<DeleteUserRequest, DeleteUserResponse>;
  assignRoleToUser: handleUnaryCall<AssignRoleToUserRequest, AssignRoleToUserResponse>;
  removeRoleFromUser: handleUnaryCall<RemoveRoleFromUserRequest, RemoveRoleFromUserResponse>;
  assignPermissionToRole: handleUnaryCall<AssignPermissionToRoleRequest, AssignPermissionToRoleResponse>;
  removePermissionFromRole: handleUnaryCall<RemovePermissionFromRoleRequest, RemovePermissionFromRoleResponse>;
  createRole: handleUnaryCall<CreateRoleRequest, RoleResponse>;
  updateRole: handleUnaryCall<UpdateRoleRequest, RoleResponse>;
  deleteRole: handleUnaryCall<DeleteRoleRequest, DeleteRoleResponse>;
  getAllRoles: handleUnaryCall<GetAllRolesRequest, GetAllRolesResponse>;
  createPermission: handleUnaryCall<CreatePermissionRequest, PermissionResponse>;
  updatePermission: handleUnaryCall<UpdatePermissionRequest, PermissionResponse>;
  deletePermission: handleUnaryCall<DeletePermissionRequest, DeletePermissionResponse>;
  getAllPermissions: handleUnaryCall<GetAllPermissionsRequest, GetAllPermissionsResponse>;
}
